var ne=Object.defineProperty;var re=(e,t,n)=>t in e?ne(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var q=(e,t,n)=>re(e,typeof t!="symbol"?t+"":t,n);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))r(o);new MutationObserver(o=>{for(const s of o)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&r(a)}).observe(document,{childList:!0,subtree:!0});function n(o){const s={};return o.integrity&&(s.integrity=o.integrity),o.referrerPolicy&&(s.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?s.credentials="include":o.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(o){if(o.ep)return;o.ep=!0;const s=n(o);fetch(o.href,s)}})();function number$2(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`Wrong positive integer: ${e}`)}function bytes$2(e,...t){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(e.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}function hash$1(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number$2(e.outputLen),number$2(e.blockLen)}function exists$1(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function output$1(e,t){bytes$2(e);const n=t.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const crypto$2=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const u8a$2=e=>e instanceof Uint8Array,createView$1=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),rotr$1=(e,t)=>e<<32-t|e>>>t,isLE$2=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE$2)throw new Error("Non little-endian hardware is not supported");function utf8ToBytes$2(e){if(typeof e!="string")throw new Error(`utf8ToBytes expected string, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}function toBytes$1(e){if(typeof e=="string"&&(e=utf8ToBytes$2(e)),!u8a$2(e))throw new Error(`expected Uint8Array, got ${typeof e}`);return e}function concatBytes$2(...e){const t=new Uint8Array(e.reduce((r,o)=>r+o.length,0));let n=0;return e.forEach(r=>{if(!u8a$2(r))throw new Error("Uint8Array expected");t.set(r,n),n+=r.length}),t}let Hash$1=class{clone(){return this._cloneInto()}};function wrapConstructor$1(e){const t=r=>e().update(toBytes$1(r)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function randomBytes$1(e=32){if(crypto$2&&typeof crypto$2.getRandomValues=="function")return crypto$2.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}function setBigUint64$1(e,t,n,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,n,r);const o=BigInt(32),s=BigInt(4294967295),a=Number(n>>o&s),l=Number(n&s),c=r?4:0,d=r?0:4;e.setUint32(t+c,a,r),e.setUint32(t+d,l,r)}let SHA2$1=class extends Hash$1{constructor(t,n,r,o){super(),this.blockLen=t,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=createView$1(this.buffer)}update(t){exists$1(this);const{view:n,buffer:r,blockLen:o}=this;t=toBytes$1(t);const s=t.length;for(let a=0;a<s;){const l=Math.min(o-this.pos,s-a);if(l===o){const c=createView$1(t);for(;o<=s-a;a+=o)this.process(c,a);continue}r.set(t.subarray(a,a+l),this.pos),this.pos+=l,a+=l,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){exists$1(this),output$1(t,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:a}=this;n[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>o-a&&(this.process(r,0),a=0);for(let u=a;u<o;u++)n[u]=0;setBigUint64$1(r,o-8,BigInt(this.length*8),s),this.process(r,0);const l=createView$1(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=c/4,h=this.get();if(d>h.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<d;u++)l.setUint32(4*u,h[u],s)}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:a,pos:l}=this;return t.length=o,t.pos=l,t.finished=s,t.destroyed=a,o%n&&t.buffer.set(r),t}};const Chi$1=(e,t,n)=>e&t^~e&n,Maj$1=(e,t,n)=>e&t^e&n^t&n,SHA256_K$1=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV$1=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W$1=new Uint32Array(64);let SHA256$2=class extends SHA2$1{constructor(){super(64,32,8,!1),this.A=IV$1[0]|0,this.B=IV$1[1]|0,this.C=IV$1[2]|0,this.D=IV$1[3]|0,this.E=IV$1[4]|0,this.F=IV$1[5]|0,this.G=IV$1[6]|0,this.H=IV$1[7]|0}get(){const{A:t,B:n,C:r,D:o,E:s,F:a,G:l,H:c}=this;return[t,n,r,o,s,a,l,c]}set(t,n,r,o,s,a,l,c){this.A=t|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=a|0,this.G=l|0,this.H=c|0}process(t,n){for(let u=0;u<16;u++,n+=4)SHA256_W$1[u]=t.getUint32(n,!1);for(let u=16;u<64;u++){const m=SHA256_W$1[u-15],g=SHA256_W$1[u-2],y=rotr$1(m,7)^rotr$1(m,18)^m>>>3,f=rotr$1(g,17)^rotr$1(g,19)^g>>>10;SHA256_W$1[u]=f+SHA256_W$1[u-7]+y+SHA256_W$1[u-16]|0}let{A:r,B:o,C:s,D:a,E:l,F:c,G:d,H:h}=this;for(let u=0;u<64;u++){const m=rotr$1(l,6)^rotr$1(l,11)^rotr$1(l,25),g=h+m+Chi$1(l,c,d)+SHA256_K$1[u]+SHA256_W$1[u]|0,f=(rotr$1(r,2)^rotr$1(r,13)^rotr$1(r,22))+Maj$1(r,o,s)|0;h=d,d=c,c=l,l=a+g|0,a=s,s=o,o=r,r=g+f|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,a=a+this.D|0,l=l+this.E|0,c=c+this.F|0,d=d+this.G|0,h=h+this.H|0,this.set(r,o,s,a,l,c,d,h)}roundClean(){SHA256_W$1.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const sha256$1=wrapConstructor$1(()=>new SHA256$2);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$4=BigInt(0),_1n$4=BigInt(1),_2n$2=BigInt(2),u8a$1=e=>e instanceof Uint8Array,hexes$1=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function bytesToHex$1(e){if(!u8a$1(e))throw new Error("Uint8Array expected");let t="";for(let n=0;n<e.length;n++)t+=hexes$1[e[n]];return t}function numberToHexUnpadded(e){const t=e.toString(16);return t.length&1?`0${t}`:t}function hexToNumber(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return BigInt(e===""?"0":`0x${e}`)}function hexToBytes$1(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);const t=e.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(t/2);for(let r=0;r<n.length;r++){const o=r*2,s=e.slice(o,o+2),a=Number.parseInt(s,16);if(Number.isNaN(a)||a<0)throw new Error("Invalid byte sequence");n[r]=a}return n}function bytesToNumberBE(e){return hexToNumber(bytesToHex$1(e))}function bytesToNumberLE(e){if(!u8a$1(e))throw new Error("Uint8Array expected");return hexToNumber(bytesToHex$1(Uint8Array.from(e).reverse()))}function numberToBytesBE(e,t){return hexToBytes$1(e.toString(16).padStart(t*2,"0"))}function numberToBytesLE(e,t){return numberToBytesBE(e,t).reverse()}function numberToVarBytesBE(e){return hexToBytes$1(numberToHexUnpadded(e))}function ensureBytes(e,t,n){let r;if(typeof t=="string")try{r=hexToBytes$1(t)}catch(s){throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${s}`)}else if(u8a$1(t))r=Uint8Array.from(t);else throw new Error(`${e} must be hex string or Uint8Array`);const o=r.length;if(typeof n=="number"&&o!==n)throw new Error(`${e} expected ${n} bytes, got ${o}`);return r}function concatBytes$1(...e){const t=new Uint8Array(e.reduce((r,o)=>r+o.length,0));let n=0;return e.forEach(r=>{if(!u8a$1(r))throw new Error("Uint8Array expected");t.set(r,n),n+=r.length}),t}function equalBytes$1(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function utf8ToBytes$1(e){if(typeof e!="string")throw new Error(`utf8ToBytes expected string, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}function bitLen(e){let t;for(t=0;e>_0n$4;e>>=_1n$4,t+=1);return t}function bitGet(e,t){return e>>BigInt(t)&_1n$4}const bitSet=(e,t,n)=>e|(n?_1n$4:_0n$4)<<BigInt(t),bitMask=e=>(_2n$2<<BigInt(e-1))-_1n$4,u8n=e=>new Uint8Array(e),u8fr=e=>Uint8Array.from(e);function createHmacDrbg(e,t,n){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=u8n(e),o=u8n(e),s=0;const a=()=>{r.fill(1),o.fill(0),s=0},l=(...u)=>n(o,r,...u),c=(u=u8n())=>{o=l(u8fr([0]),u),r=l(),u.length!==0&&(o=l(u8fr([1]),u),r=l())},d=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const m=[];for(;u<t;){r=l();const g=r.slice();m.push(g),u+=r.length}return concatBytes$1(...m)};return(u,m)=>{a(),c(u);let g;for(;!(g=m(d()));)c();return a(),g}}const validatorFns={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||e instanceof Uint8Array,isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function validateObject(e,t,n={}){const r=(o,s,a)=>{const l=validatorFns[s];if(typeof l!="function")throw new Error(`Invalid validator "${s}", expected function`);const c=e[o];if(!(a&&c===void 0)&&!l(c,e))throw new Error(`Invalid param ${String(o)}=${c} (${typeof c}), expected ${s}`)};for(const[o,s]of Object.entries(t))r(o,s,!1);for(const[o,s]of Object.entries(n))r(o,s,!0);return e}const ut=Object.freeze(Object.defineProperty({__proto__:null,bitGet,bitLen,bitMask,bitSet,bytesToHex:bytesToHex$1,bytesToNumberBE,bytesToNumberLE,concatBytes:concatBytes$1,createHmacDrbg,ensureBytes,equalBytes:equalBytes$1,hexToBytes:hexToBytes$1,hexToNumber,numberToBytesBE,numberToBytesLE,numberToHexUnpadded,numberToVarBytesBE,utf8ToBytes:utf8ToBytes$1,validateObject},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$3=BigInt(0),_1n$3=BigInt(1),_2n$1=BigInt(2),_3n$1=BigInt(3),_4n=BigInt(4),_5n=BigInt(5),_8n=BigInt(8);BigInt(9);BigInt(16);function mod(e,t){const n=e%t;return n>=_0n$3?n:t+n}function pow(e,t,n){if(n<=_0n$3||t<_0n$3)throw new Error("Expected power/modulo > 0");if(n===_1n$3)return _0n$3;let r=_1n$3;for(;t>_0n$3;)t&_1n$3&&(r=r*e%n),e=e*e%n,t>>=_1n$3;return r}function pow2(e,t,n){let r=e;for(;t-- >_0n$3;)r*=r,r%=n;return r}function invert(e,t){if(e===_0n$3||t<=_0n$3)throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);let n=mod(e,t),r=t,o=_0n$3,s=_1n$3;for(;n!==_0n$3;){const l=r/n,c=r%n,d=o-s*l;r=n,n=c,o=s,s=d}if(r!==_1n$3)throw new Error("invert: does not exist");return mod(o,t)}function tonelliShanks(e){const t=(e-_1n$3)/_2n$1;let n,r,o;for(n=e-_1n$3,r=0;n%_2n$1===_0n$3;n/=_2n$1,r++);for(o=_2n$1;o<e&&pow(o,t,e)!==e-_1n$3;o++);if(r===1){const a=(e+_1n$3)/_4n;return function(c,d){const h=c.pow(d,a);if(!c.eql(c.sqr(h),d))throw new Error("Cannot find square root");return h}}const s=(n+_1n$3)/_2n$1;return function(l,c){if(l.pow(c,t)===l.neg(l.ONE))throw new Error("Cannot find square root");let d=r,h=l.pow(l.mul(l.ONE,o),n),u=l.pow(c,s),m=l.pow(c,n);for(;!l.eql(m,l.ONE);){if(l.eql(m,l.ZERO))return l.ZERO;let g=1;for(let f=l.sqr(m);g<d&&!l.eql(f,l.ONE);g++)f=l.sqr(f);const y=l.pow(h,_1n$3<<BigInt(d-g-1));h=l.sqr(y),u=l.mul(u,y),m=l.mul(m,h),d=g}return u}}function FpSqrt(e){if(e%_4n===_3n$1){const t=(e+_1n$3)/_4n;return function(r,o){const s=r.pow(o,t);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(e%_8n===_5n){const t=(e-_5n)/_8n;return function(r,o){const s=r.mul(o,_2n$1),a=r.pow(s,t),l=r.mul(o,a),c=r.mul(r.mul(l,_2n$1),a),d=r.mul(l,r.sub(c,r.ONE));if(!r.eql(r.sqr(d),o))throw new Error("Cannot find square root");return d}}return tonelliShanks(e)}const FIELD_FIELDS=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function validateField(e){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=FIELD_FIELDS.reduce((r,o)=>(r[o]="function",r),t);return validateObject(e,n)}function FpPow(e,t,n){if(n<_0n$3)throw new Error("Expected power > 0");if(n===_0n$3)return e.ONE;if(n===_1n$3)return t;let r=e.ONE,o=t;for(;n>_0n$3;)n&_1n$3&&(r=e.mul(r,o)),o=e.sqr(o),n>>=_1n$3;return r}function FpInvertBatch(e,t){const n=new Array(t.length),r=t.reduce((s,a,l)=>e.is0(a)?s:(n[l]=s,e.mul(s,a)),e.ONE),o=e.inv(r);return t.reduceRight((s,a,l)=>e.is0(a)?s:(n[l]=e.mul(s,n[l]),e.mul(s,a)),o),n}function nLength(e,t){const n=t!==void 0?t:e.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function Field(e,t,n=!1,r={}){if(e<=_0n$3)throw new Error(`Expected Field ORDER > 0, got ${e}`);const{nBitLength:o,nByteLength:s}=nLength(e,t);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");const a=FpSqrt(e),l=Object.freeze({ORDER:e,BITS:o,BYTES:s,MASK:bitMask(o),ZERO:_0n$3,ONE:_1n$3,create:c=>mod(c,e),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return _0n$3<=c&&c<e},is0:c=>c===_0n$3,isOdd:c=>(c&_1n$3)===_1n$3,neg:c=>mod(-c,e),eql:(c,d)=>c===d,sqr:c=>mod(c*c,e),add:(c,d)=>mod(c+d,e),sub:(c,d)=>mod(c-d,e),mul:(c,d)=>mod(c*d,e),pow:(c,d)=>FpPow(l,c,d),div:(c,d)=>mod(c*invert(d,e),e),sqrN:c=>c*c,addN:(c,d)=>c+d,subN:(c,d)=>c-d,mulN:(c,d)=>c*d,inv:c=>invert(c,e),sqrt:r.sqrt||(c=>a(l,c)),invertBatch:c=>FpInvertBatch(l,c),cmov:(c,d,h)=>h?d:c,toBytes:c=>n?numberToBytesLE(c,s):numberToBytesBE(c,s),fromBytes:c=>{if(c.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);return n?bytesToNumberLE(c):bytesToNumberBE(c)}});return Object.freeze(l)}function getFieldBytesLength(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function getMinHashLength(e){const t=getFieldBytesLength(e);return t+Math.ceil(t/2)}function mapHashToField(e,t,n=!1){const r=e.length,o=getFieldBytesLength(t),s=getMinHashLength(t);if(r<16||r<s||r>1024)throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);const a=n?bytesToNumberBE(e):bytesToNumberLE(e),l=mod(a,t-_1n$3)+_1n$3;return n?numberToBytesLE(l,o):numberToBytesBE(l,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$2=BigInt(0),_1n$2=BigInt(1);function wNAF(e,t){const n=(o,s)=>{const a=s.negate();return o?a:s},r=o=>{const s=Math.ceil(t/o)+1,a=2**(o-1);return{windows:s,windowSize:a}};return{constTimeNegate:n,unsafeLadder(o,s){let a=e.ZERO,l=o;for(;s>_0n$2;)s&_1n$2&&(a=a.add(l)),l=l.double(),s>>=_1n$2;return a},precomputeWindow(o,s){const{windows:a,windowSize:l}=r(s),c=[];let d=o,h=d;for(let u=0;u<a;u++){h=d,c.push(h);for(let m=1;m<l;m++)h=h.add(d),c.push(h);d=h.double()}return c},wNAF(o,s,a){const{windows:l,windowSize:c}=r(o);let d=e.ZERO,h=e.BASE;const u=BigInt(2**o-1),m=2**o,g=BigInt(o);for(let y=0;y<l;y++){const f=y*c;let w=Number(a&u);a>>=g,w>c&&(w-=m,a+=_1n$2);const b=f,$=f+Math.abs(w)-1,x=y%2!==0,A=w<0;w===0?h=h.add(n(x,s[b])):d=d.add(n(A,s[$]))}return{p:d,f:h}},wNAFCached(o,s,a,l){const c=o._WINDOW_SIZE||1;let d=s.get(o);return d||(d=this.precomputeWindow(o,c),c!==1&&s.set(o,l(d))),this.wNAF(c,d,a)}}}function validateBasic(e){return validateField(e.Fp),validateObject(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...nLength(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function validatePointOpts(e){const t=validateBasic(e);validateObject(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=t;if(n){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}const{bytesToNumberBE:b2n,hexToBytes:h2b}=ut,DER={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(e){const{Err:t}=DER;if(e.length<2||e[0]!==2)throw new t("Invalid signature integer tag");const n=e[1],r=e.subarray(2,n+2);if(!n||r.length!==n)throw new t("Invalid signature integer: wrong length");if(r[0]&128)throw new t("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("Invalid signature integer: unnecessary leading zero");return{d:b2n(r),l:e.subarray(n+2)}},toSig(e){const{Err:t}=DER,n=typeof e=="string"?h2b(e):e;if(!(n instanceof Uint8Array))throw new Error("ui8a expected");let r=n.length;if(r<2||n[0]!=48)throw new t("Invalid signature tag");if(n[1]!==r-2)throw new t("Invalid signature: incorrect length");const{d:o,l:s}=DER._parseInt(n.subarray(2)),{d:a,l}=DER._parseInt(s);if(l.length)throw new t("Invalid signature: left bytes after parsing");return{r:o,s:a}},hexFromSig(e){const t=d=>Number.parseInt(d[0],16)&8?"00"+d:d,n=d=>{const h=d.toString(16);return h.length&1?`0${h}`:h},r=t(n(e.s)),o=t(n(e.r)),s=r.length/2,a=o.length/2,l=n(s),c=n(a);return`30${n(a+s+4)}02${c}${o}02${l}${r}`}},_0n$1=BigInt(0),_1n$1=BigInt(1);BigInt(2);const _3n=BigInt(3);BigInt(4);function weierstrassPoints(e){const t=validatePointOpts(e),{Fp:n}=t,r=t.toBytes||((y,f,w)=>{const b=f.toAffine();return concatBytes$1(Uint8Array.from([4]),n.toBytes(b.x),n.toBytes(b.y))}),o=t.fromBytes||(y=>{const f=y.subarray(1),w=n.fromBytes(f.subarray(0,n.BYTES)),b=n.fromBytes(f.subarray(n.BYTES,2*n.BYTES));return{x:w,y:b}});function s(y){const{a:f,b:w}=t,b=n.sqr(y),$=n.mul(b,y);return n.add(n.add($,n.mul(y,f)),w)}if(!n.eql(n.sqr(t.Gy),s(t.Gx)))throw new Error("bad generator point: equation left != right");function a(y){return typeof y=="bigint"&&_0n$1<y&&y<t.n}function l(y){if(!a(y))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(y){const{allowedPrivateKeyLengths:f,nByteLength:w,wrapPrivateKey:b,n:$}=t;if(f&&typeof y!="bigint"){if(y instanceof Uint8Array&&(y=bytesToHex$1(y)),typeof y!="string"||!f.includes(y.length))throw new Error("Invalid key");y=y.padStart(w*2,"0")}let x;try{x=typeof y=="bigint"?y:bytesToNumberBE(ensureBytes("private key",y,w))}catch{throw new Error(`private key must be ${w} bytes, hex or bigint, not ${typeof y}`)}return b&&(x=mod(x,$)),l(x),x}const d=new Map;function h(y){if(!(y instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(f,w,b){if(this.px=f,this.py=w,this.pz=b,f==null||!n.isValid(f))throw new Error("x required");if(w==null||!n.isValid(w))throw new Error("y required");if(b==null||!n.isValid(b))throw new Error("z required")}static fromAffine(f){const{x:w,y:b}=f||{};if(!f||!n.isValid(w)||!n.isValid(b))throw new Error("invalid affine point");if(f instanceof u)throw new Error("projective point not allowed");const $=x=>n.eql(x,n.ZERO);return $(w)&&$(b)?u.ZERO:new u(w,b,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(f){const w=n.invertBatch(f.map(b=>b.pz));return f.map((b,$)=>b.toAffine(w[$])).map(u.fromAffine)}static fromHex(f){const w=u.fromAffine(o(ensureBytes("pointHex",f)));return w.assertValidity(),w}static fromPrivateKey(f){return u.BASE.multiply(c(f))}_setWindowSize(f){this._WINDOW_SIZE=f,d.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:f,y:w}=this.toAffine();if(!n.isValid(f)||!n.isValid(w))throw new Error("bad point: x or y not FE");const b=n.sqr(w),$=s(f);if(!n.eql(b,$))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:f}=this.toAffine();if(n.isOdd)return!n.isOdd(f);throw new Error("Field doesn't support isOdd")}equals(f){h(f);const{px:w,py:b,pz:$}=this,{px:x,py:A,pz:T}=f,v=n.eql(n.mul(w,T),n.mul(x,$)),_=n.eql(n.mul(b,T),n.mul(A,$));return v&&_}negate(){return new u(this.px,n.neg(this.py),this.pz)}double(){const{a:f,b:w}=t,b=n.mul(w,_3n),{px:$,py:x,pz:A}=this;let T=n.ZERO,v=n.ZERO,_=n.ZERO,S=n.mul($,$),U=n.mul(x,x),I=n.mul(A,A),L=n.mul($,x);return L=n.add(L,L),_=n.mul($,A),_=n.add(_,_),T=n.mul(f,_),v=n.mul(b,I),v=n.add(T,v),T=n.sub(U,v),v=n.add(U,v),v=n.mul(T,v),T=n.mul(L,T),_=n.mul(b,_),I=n.mul(f,I),L=n.sub(S,I),L=n.mul(f,L),L=n.add(L,_),_=n.add(S,S),S=n.add(_,S),S=n.add(S,I),S=n.mul(S,L),v=n.add(v,S),I=n.mul(x,A),I=n.add(I,I),S=n.mul(I,L),T=n.sub(T,S),_=n.mul(I,U),_=n.add(_,_),_=n.add(_,_),new u(T,v,_)}add(f){h(f);const{px:w,py:b,pz:$}=this,{px:x,py:A,pz:T}=f;let v=n.ZERO,_=n.ZERO,S=n.ZERO;const U=t.a,I=n.mul(t.b,_3n);let L=n.mul(w,x),P=n.mul(b,A),O=n.mul($,T),W=n.add(w,b),E=n.add(x,A);W=n.mul(W,E),E=n.add(L,P),W=n.sub(W,E),E=n.add(w,$);let B=n.add(x,T);return E=n.mul(E,B),B=n.add(L,O),E=n.sub(E,B),B=n.add(b,$),v=n.add(A,T),B=n.mul(B,v),v=n.add(P,O),B=n.sub(B,v),S=n.mul(U,E),v=n.mul(I,O),S=n.add(v,S),v=n.sub(P,S),S=n.add(P,S),_=n.mul(v,S),P=n.add(L,L),P=n.add(P,L),O=n.mul(U,O),E=n.mul(I,E),P=n.add(P,O),O=n.sub(L,O),O=n.mul(U,O),E=n.add(E,O),L=n.mul(P,E),_=n.add(_,L),L=n.mul(B,E),v=n.mul(W,v),v=n.sub(v,L),L=n.mul(W,P),S=n.mul(B,S),S=n.add(S,L),new u(v,_,S)}subtract(f){return this.add(f.negate())}is0(){return this.equals(u.ZERO)}wNAF(f){return g.wNAFCached(this,d,f,w=>{const b=n.invertBatch(w.map($=>$.pz));return w.map(($,x)=>$.toAffine(b[x])).map(u.fromAffine)})}multiplyUnsafe(f){const w=u.ZERO;if(f===_0n$1)return w;if(l(f),f===_1n$1)return this;const{endo:b}=t;if(!b)return g.unsafeLadder(this,f);let{k1neg:$,k1:x,k2neg:A,k2:T}=b.splitScalar(f),v=w,_=w,S=this;for(;x>_0n$1||T>_0n$1;)x&_1n$1&&(v=v.add(S)),T&_1n$1&&(_=_.add(S)),S=S.double(),x>>=_1n$1,T>>=_1n$1;return $&&(v=v.negate()),A&&(_=_.negate()),_=new u(n.mul(_.px,b.beta),_.py,_.pz),v.add(_)}multiply(f){l(f);let w=f,b,$;const{endo:x}=t;if(x){const{k1neg:A,k1:T,k2neg:v,k2:_}=x.splitScalar(w);let{p:S,f:U}=this.wNAF(T),{p:I,f:L}=this.wNAF(_);S=g.constTimeNegate(A,S),I=g.constTimeNegate(v,I),I=new u(n.mul(I.px,x.beta),I.py,I.pz),b=S.add(I),$=U.add(L)}else{const{p:A,f:T}=this.wNAF(w);b=A,$=T}return u.normalizeZ([b,$])[0]}multiplyAndAddUnsafe(f,w,b){const $=u.BASE,x=(T,v)=>v===_0n$1||v===_1n$1||!T.equals($)?T.multiplyUnsafe(v):T.multiply(v),A=x(this,w).add(x(f,b));return A.is0()?void 0:A}toAffine(f){const{px:w,py:b,pz:$}=this,x=this.is0();f==null&&(f=x?n.ONE:n.inv($));const A=n.mul(w,f),T=n.mul(b,f),v=n.mul($,f);if(x)return{x:n.ZERO,y:n.ZERO};if(!n.eql(v,n.ONE))throw new Error("invZ was invalid");return{x:A,y:T}}isTorsionFree(){const{h:f,isTorsionFree:w}=t;if(f===_1n$1)return!0;if(w)return w(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:f,clearCofactor:w}=t;return f===_1n$1?this:w?w(u,this):this.multiplyUnsafe(t.h)}toRawBytes(f=!0){return this.assertValidity(),r(u,this,f)}toHex(f=!0){return bytesToHex$1(this.toRawBytes(f))}}u.BASE=new u(t.Gx,t.Gy,n.ONE),u.ZERO=new u(n.ZERO,n.ONE,n.ZERO);const m=t.nBitLength,g=wNAF(u,t.endo?Math.ceil(m/2):m);return{CURVE:t,ProjectivePoint:u,normPrivateKeyToScalar:c,weierstrassEquation:s,isWithinCurveOrder:a}}function validateOpts(e){const t=validateBasic(e);return validateObject(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function weierstrass(e){const t=validateOpts(e),{Fp:n,n:r}=t,o=n.BYTES+1,s=2*n.BYTES+1;function a(E){return _0n$1<E&&E<n.ORDER}function l(E){return mod(E,r)}function c(E){return invert(E,r)}const{ProjectivePoint:d,normPrivateKeyToScalar:h,weierstrassEquation:u,isWithinCurveOrder:m}=weierstrassPoints({...t,toBytes(E,B,k){const R=B.toAffine(),C=n.toBytes(R.x),H=concatBytes$1;return k?H(Uint8Array.from([B.hasEvenY()?2:3]),C):H(Uint8Array.from([4]),C,n.toBytes(R.y))},fromBytes(E){const B=E.length,k=E[0],R=E.subarray(1);if(B===o&&(k===2||k===3)){const C=bytesToNumberBE(R);if(!a(C))throw new Error("Point is not on curve");const H=u(C);let M=n.sqrt(H);const N=(M&_1n$1)===_1n$1;return(k&1)===1!==N&&(M=n.neg(M)),{x:C,y:M}}else if(B===s&&k===4){const C=n.fromBytes(R.subarray(0,n.BYTES)),H=n.fromBytes(R.subarray(n.BYTES,2*n.BYTES));return{x:C,y:H}}else throw new Error(`Point of length ${B} was invalid. Expected ${o} compressed bytes or ${s} uncompressed bytes`)}}),g=E=>bytesToHex$1(numberToBytesBE(E,t.nByteLength));function y(E){const B=r>>_1n$1;return E>B}function f(E){return y(E)?l(-E):E}const w=(E,B,k)=>bytesToNumberBE(E.slice(B,k));class b{constructor(B,k,R){this.r=B,this.s=k,this.recovery=R,this.assertValidity()}static fromCompact(B){const k=t.nByteLength;return B=ensureBytes("compactSignature",B,k*2),new b(w(B,0,k),w(B,k,2*k))}static fromDER(B){const{r:k,s:R}=DER.toSig(ensureBytes("DER",B));return new b(k,R)}assertValidity(){if(!m(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!m(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(B){return new b(this.r,this.s,B)}recoverPublicKey(B){const{r:k,s:R,recovery:C}=this,H=_(ensureBytes("msgHash",B));if(C==null||![0,1,2,3].includes(C))throw new Error("recovery id invalid");const M=C===2||C===3?k+t.n:k;if(M>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const N=C&1?"03":"02",D=d.fromHex(N+g(M)),V=c(M),F=l(-H*V),X=l(R*V),z=d.BASE.multiplyAndAddUnsafe(D,F,X);if(!z)throw new Error("point at infinify");return z.assertValidity(),z}hasHighS(){return y(this.s)}normalizeS(){return this.hasHighS()?new b(this.r,l(-this.s),this.recovery):this}toDERRawBytes(){return hexToBytes$1(this.toDERHex())}toDERHex(){return DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return hexToBytes$1(this.toCompactHex())}toCompactHex(){return g(this.r)+g(this.s)}}const $={isValidPrivateKey(E){try{return h(E),!0}catch{return!1}},normPrivateKeyToScalar:h,randomPrivateKey:()=>{const E=getMinHashLength(t.n);return mapHashToField(t.randomBytes(E),t.n)},precompute(E=8,B=d.BASE){return B._setWindowSize(E),B.multiply(BigInt(3)),B}};function x(E,B=!0){return d.fromPrivateKey(E).toRawBytes(B)}function A(E){const B=E instanceof Uint8Array,k=typeof E=="string",R=(B||k)&&E.length;return B?R===o||R===s:k?R===2*o||R===2*s:E instanceof d}function T(E,B,k=!0){if(A(E))throw new Error("first arg must be private key");if(!A(B))throw new Error("second arg must be public key");return d.fromHex(B).multiply(h(E)).toRawBytes(k)}const v=t.bits2int||function(E){const B=bytesToNumberBE(E),k=E.length*8-t.nBitLength;return k>0?B>>BigInt(k):B},_=t.bits2int_modN||function(E){return l(v(E))},S=bitMask(t.nBitLength);function U(E){if(typeof E!="bigint")throw new Error("bigint expected");if(!(_0n$1<=E&&E<S))throw new Error(`bigint expected < 2^${t.nBitLength}`);return numberToBytesBE(E,t.nByteLength)}function I(E,B,k=L){if(["recovered","canonical"].some(j=>j in k))throw new Error("sign() legacy options not supported");const{hash:R,randomBytes:C}=t;let{lowS:H,prehash:M,extraEntropy:N}=k;H==null&&(H=!0),E=ensureBytes("msgHash",E),M&&(E=ensureBytes("prehashed msgHash",R(E)));const D=_(E),V=h(B),F=[U(V),U(D)];if(N!=null){const j=N===!0?C(n.BYTES):N;F.push(ensureBytes("extraEntropy",j))}const X=concatBytes$1(...F),z=D;function Y(j){const G=v(j);if(!m(G))return;const Q=c(G),Z=d.BASE.multiply(G).toAffine(),K=l(Z.x);if(K===_0n$1)return;const J=l(Q*l(z+K*V));if(J===_0n$1)return;let ee=(Z.x===K?0:2)|Number(Z.y&_1n$1),te=J;return H&&y(J)&&(te=f(J),ee^=1),new b(K,te,ee)}return{seed:X,k2sig:Y}}const L={lowS:t.lowS,prehash:!1},P={lowS:t.lowS,prehash:!1};function O(E,B,k=L){const{seed:R,k2sig:C}=I(E,B,k),H=t;return createHmacDrbg(H.hash.outputLen,H.nByteLength,H.hmac)(R,C)}d.BASE._setWindowSize(8);function W(E,B,k,R=P){var Z;const C=E;if(B=ensureBytes("msgHash",B),k=ensureBytes("publicKey",k),"strict"in R)throw new Error("options.strict was renamed to lowS");const{lowS:H,prehash:M}=R;let N,D;try{if(typeof C=="string"||C instanceof Uint8Array)try{N=b.fromDER(C)}catch(K){if(!(K instanceof DER.Err))throw K;N=b.fromCompact(C)}else if(typeof C=="object"&&typeof C.r=="bigint"&&typeof C.s=="bigint"){const{r:K,s:J}=C;N=new b(K,J)}else throw new Error("PARSE");D=d.fromHex(k)}catch(K){if(K.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(H&&N.hasHighS())return!1;M&&(B=t.hash(B));const{r:V,s:F}=N,X=_(B),z=c(F),Y=l(X*z),j=l(V*z),G=(Z=d.BASE.multiplyAndAddUnsafe(D,Y,j))==null?void 0:Z.toAffine();return G?l(G.x)===V:!1}return{CURVE:t,getPublicKey:x,getSharedSecret:T,sign:O,verify:W,ProjectivePoint:d,Signature:b,utils:$}}let HMAC$1=class extends Hash$1{constructor(t,n){super(),this.finished=!1,this.destroyed=!1,hash$1(t);const r=toBytes$1(n);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?t.create().update(r).digest():r);for(let a=0;a<s.length;a++)s[a]^=54;this.iHash.update(s),this.oHash=t.create();for(let a=0;a<s.length;a++)s[a]^=106;this.oHash.update(s),s.fill(0)}update(t){return exists$1(this),this.iHash.update(t),this}digestInto(t){exists$1(this),bytes$2(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:s,blockLen:a,outputLen:l}=this;return t=t,t.finished=o,t.destroyed=s,t.blockLen=a,t.outputLen=l,t.oHash=n._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const hmac$1=(e,t,n)=>new HMAC$1(e,t).update(n).digest();hmac$1.create=(e,t)=>new HMAC$1(e,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function getHash(e){return{hash:e,hmac:(t,...n)=>hmac$1(e,t,concatBytes$2(...n)),randomBytes:randomBytes$1}}function createCurve(e,t){const n=r=>weierstrass({...e,...getHash(r)});return Object.freeze({...n(t),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const secp256k1P=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),secp256k1N=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),_1n=BigInt(1),_2n=BigInt(2),divNearest=(e,t)=>(e+t/_2n)/t;function sqrtMod(e){const t=secp256k1P,n=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),a=BigInt(23),l=BigInt(44),c=BigInt(88),d=e*e*e%t,h=d*d*e%t,u=pow2(h,n,t)*h%t,m=pow2(u,n,t)*h%t,g=pow2(m,_2n,t)*d%t,y=pow2(g,o,t)*g%t,f=pow2(y,s,t)*y%t,w=pow2(f,l,t)*f%t,b=pow2(w,c,t)*w%t,$=pow2(b,l,t)*f%t,x=pow2($,n,t)*h%t,A=pow2(x,a,t)*y%t,T=pow2(A,r,t)*d%t,v=pow2(T,_2n,t);if(!Fp.eql(Fp.sqr(v),e))throw new Error("Cannot find square root");return v}const Fp=Field(secp256k1P,void 0,void 0,{sqrt:sqrtMod}),secp256k1=createCurve({a:BigInt(0),b:BigInt(7),Fp,n:secp256k1N,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=secp256k1N,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-_1n*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,a=BigInt("0x100000000000000000000000000000000"),l=divNearest(s*e,t),c=divNearest(-r*e,t);let d=mod(e-l*n-c*o,t),h=mod(-l*r-c*s,t);const u=d>a,m=h>a;if(u&&(d=t-d),m&&(h=t-h),d>a||h>a)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:u,k1:d,k2neg:m,k2:h}}}},sha256$1),_0n=BigInt(0),fe=e=>typeof e=="bigint"&&_0n<e&&e<secp256k1P,ge=e=>typeof e=="bigint"&&_0n<e&&e<secp256k1N,TAGGED_HASH_PREFIXES={};function taggedHash(e,...t){let n=TAGGED_HASH_PREFIXES[e];if(n===void 0){const r=sha256$1(Uint8Array.from(e,o=>o.charCodeAt(0)));n=concatBytes$1(r,r),TAGGED_HASH_PREFIXES[e]=n}return sha256$1(concatBytes$1(n,...t))}const pointToBytes=e=>e.toRawBytes(!0).slice(1),numTo32b=e=>numberToBytesBE(e,32),modP=e=>mod(e,secp256k1P),modN=e=>mod(e,secp256k1N),Point=secp256k1.ProjectivePoint,GmulAdd=(e,t,n)=>Point.BASE.multiplyAndAddUnsafe(e,t,n);function schnorrGetExtPubKey(e){let t=secp256k1.utils.normPrivateKeyToScalar(e),n=Point.fromPrivateKey(t);return{scalar:n.hasEvenY()?t:modN(-t),bytes:pointToBytes(n)}}function lift_x(e){if(!fe(e))throw new Error("bad x: need 0 < x < p");const t=modP(e*e),n=modP(t*e+BigInt(7));let r=sqrtMod(n);r%_2n!==_0n&&(r=modP(-r));const o=new Point(e,r,_1n);return o.assertValidity(),o}function challenge(...e){return modN(bytesToNumberBE(taggedHash("BIP0340/challenge",...e)))}function schnorrGetPublicKey(e){return schnorrGetExtPubKey(e).bytes}function schnorrSign(e,t,n=randomBytes$1(32)){const r=ensureBytes("message",e),{bytes:o,scalar:s}=schnorrGetExtPubKey(t),a=ensureBytes("auxRand",n,32),l=numTo32b(s^bytesToNumberBE(taggedHash("BIP0340/aux",a))),c=taggedHash("BIP0340/nonce",l,o,r),d=modN(bytesToNumberBE(c));if(d===_0n)throw new Error("sign failed: k is zero");const{bytes:h,scalar:u}=schnorrGetExtPubKey(d),m=challenge(h,o,r),g=new Uint8Array(64);if(g.set(h,0),g.set(numTo32b(modN(u+m*s)),32),!schnorrVerify(g,r,o))throw new Error("sign: Invalid signature produced");return g}function schnorrVerify(e,t,n){const r=ensureBytes("signature",e,64),o=ensureBytes("message",t),s=ensureBytes("publicKey",n,32);try{const a=lift_x(bytesToNumberBE(s)),l=bytesToNumberBE(r.subarray(0,32));if(!fe(l))return!1;const c=bytesToNumberBE(r.subarray(32,64));if(!ge(c))return!1;const d=challenge(numTo32b(l),pointToBytes(a),o),h=GmulAdd(a,c,modN(-d));return!(!h||!h.hasEvenY()||h.toAffine().x!==l)}catch{return!1}}const schnorr={getPublicKey:schnorrGetPublicKey,sign:schnorrSign,verify:schnorrVerify,utils:{randomPrivateKey:secp256k1.utils.randomPrivateKey,lift_x,pointToBytes,numberToBytesBE,bytesToNumberBE,taggedHash,mod}},crypto$1=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const u8a=e=>e instanceof Uint8Array,createView=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),rotr=(e,t)=>e<<32-t|e>>>t,isLE$1=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE$1)throw new Error("Non little-endian hardware is not supported");const hexes=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function bytesToHex(e){if(!u8a(e))throw new Error("Uint8Array expected");let t="";for(let n=0;n<e.length;n++)t+=hexes[e[n]];return t}function hexToBytes(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);const t=e.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(t/2);for(let r=0;r<n.length;r++){const o=r*2,s=e.slice(o,o+2),a=Number.parseInt(s,16);if(Number.isNaN(a)||a<0)throw new Error("Invalid byte sequence");n[r]=a}return n}function utf8ToBytes(e){if(typeof e!="string")throw new Error(`utf8ToBytes expected string, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}function toBytes(e){if(typeof e=="string"&&(e=utf8ToBytes(e)),!u8a(e))throw new Error(`expected Uint8Array, got ${typeof e}`);return e}function concatBytes(...e){const t=new Uint8Array(e.reduce((r,o)=>r+o.length,0));let n=0;return e.forEach(r=>{if(!u8a(r))throw new Error("Uint8Array expected");t.set(r,n),n+=r.length}),t}class Hash{clone(){return this._cloneInto()}}function wrapConstructor(e){const t=r=>e().update(toBytes(r)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function randomBytes(e=32){if(crypto$1&&typeof crypto$1.getRandomValues=="function")return crypto$1.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}function number$1(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`Wrong positive integer: ${e}`)}function bool$1(e){if(typeof e!="boolean")throw new Error(`Expected boolean, not ${e}`)}function bytes$1(e,...t){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(e.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}function hash(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number$1(e.outputLen),number$1(e.blockLen)}function exists(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function output(e,t){bytes$1(e);const n=t.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const assert={number:number$1,bool:bool$1,bytes:bytes$1,hash,exists,output};function setBigUint64(e,t,n,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,n,r);const o=BigInt(32),s=BigInt(4294967295),a=Number(n>>o&s),l=Number(n&s),c=r?4:0,d=r?0:4;e.setUint32(t+c,a,r),e.setUint32(t+d,l,r)}class SHA2 extends Hash{constructor(t,n,r,o){super(),this.blockLen=t,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=createView(this.buffer)}update(t){assert.exists(this);const{view:n,buffer:r,blockLen:o}=this;t=toBytes(t);const s=t.length;for(let a=0;a<s;){const l=Math.min(o-this.pos,s-a);if(l===o){const c=createView(t);for(;o<=s-a;a+=o)this.process(c,a);continue}r.set(t.subarray(a,a+l),this.pos),this.pos+=l,a+=l,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){assert.exists(this),assert.output(t,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:a}=this;n[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>o-a&&(this.process(r,0),a=0);for(let u=a;u<o;u++)n[u]=0;setBigUint64(r,o-8,BigInt(this.length*8),s),this.process(r,0);const l=createView(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=c/4,h=this.get();if(d>h.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<d;u++)l.setUint32(4*u,h[u],s)}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:a,pos:l}=this;return t.length=o,t.pos=l,t.finished=s,t.destroyed=a,o%n&&t.buffer.set(r),t}}const Chi=(e,t,n)=>e&t^~e&n,Maj=(e,t,n)=>e&t^e&n^t&n,SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W=new Uint32Array(64);let SHA256$1=class extends SHA2{constructor(){super(64,32,8,!1),this.A=IV[0]|0,this.B=IV[1]|0,this.C=IV[2]|0,this.D=IV[3]|0,this.E=IV[4]|0,this.F=IV[5]|0,this.G=IV[6]|0,this.H=IV[7]|0}get(){const{A:t,B:n,C:r,D:o,E:s,F:a,G:l,H:c}=this;return[t,n,r,o,s,a,l,c]}set(t,n,r,o,s,a,l,c){this.A=t|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=a|0,this.G=l|0,this.H=c|0}process(t,n){for(let u=0;u<16;u++,n+=4)SHA256_W[u]=t.getUint32(n,!1);for(let u=16;u<64;u++){const m=SHA256_W[u-15],g=SHA256_W[u-2],y=rotr(m,7)^rotr(m,18)^m>>>3,f=rotr(g,17)^rotr(g,19)^g>>>10;SHA256_W[u]=f+SHA256_W[u-7]+y+SHA256_W[u-16]|0}let{A:r,B:o,C:s,D:a,E:l,F:c,G:d,H:h}=this;for(let u=0;u<64;u++){const m=rotr(l,6)^rotr(l,11)^rotr(l,25),g=h+m+Chi(l,c,d)+SHA256_K[u]+SHA256_W[u]|0,f=(rotr(r,2)^rotr(r,13)^rotr(r,22))+Maj(r,o,s)|0;h=d,d=c,c=l,l=a+g|0,a=s,s=o,o=r,r=g+f|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,a=a+this.D|0,l=l+this.E|0,c=c+this.F|0,d=d+this.G|0,h=h+this.H|0,this.set(r,o,s,a,l,c,d,h)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};class SHA224 extends SHA256$1{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const sha256=wrapConstructor(()=>new SHA256$1);wrapConstructor(()=>new SHA224);/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function assertNumber(e){if(!Number.isSafeInteger(e))throw new Error(`Wrong integer: ${e}`)}function chain(...e){const t=(o,s)=>a=>o(s(a)),n=Array.from(e).reverse().reduce((o,s)=>o?t(o,s.encode):s.encode,void 0),r=e.reduce((o,s)=>o?t(o,s.decode):s.decode,void 0);return{encode:n,decode:r}}function alphabet(e){return{encode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return t.map(n=>{if(assertNumber(n),n<0||n>=e.length)throw new Error(`Digit index outside alphabet: ${n} (alphabet: ${e.length})`);return e[n]})},decode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="string")throw new Error("alphabet.decode input should be array of strings");return t.map(n=>{if(typeof n!="string")throw new Error(`alphabet.decode: not string element=${n}`);const r=e.indexOf(n);if(r===-1)throw new Error(`Unknown letter: "${n}". Allowed: ${e}`);return r})}}}function join(e=""){if(typeof e!="string")throw new Error("join separator should be string");return{encode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="string")throw new Error("join.encode input should be array of strings");for(let n of t)if(typeof n!="string")throw new Error(`join.encode: non-string input=${n}`);return t.join(e)},decode:t=>{if(typeof t!="string")throw new Error("join.decode input should be string");return t.split(e)}}}function padding(e,t="="){if(assertNumber(e),typeof t!="string")throw new Error("padding chr should be string");return{encode(n){if(!Array.isArray(n)||n.length&&typeof n[0]!="string")throw new Error("padding.encode input should be array of strings");for(let r of n)if(typeof r!="string")throw new Error(`padding.encode: non-string input=${r}`);for(;n.length*e%8;)n.push(t);return n},decode(n){if(!Array.isArray(n)||n.length&&typeof n[0]!="string")throw new Error("padding.encode input should be array of strings");for(let o of n)if(typeof o!="string")throw new Error(`padding.decode: non-string input=${o}`);let r=n.length;if(r*e%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;r>0&&n[r-1]===t;r--)if(!((r-1)*e%8))throw new Error("Invalid padding: string has too much padding");return n.slice(0,r)}}}function normalize(e){if(typeof e!="function")throw new Error("normalize fn should be function");return{encode:t=>t,decode:t=>e(t)}}function convertRadix(e,t,n){if(t<2)throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: wrong to=${n}, base cannot be less than 2`);if(!Array.isArray(e))throw new Error("convertRadix: data should be array");if(!e.length)return[];let r=0;const o=[],s=Array.from(e);for(s.forEach(a=>{if(assertNumber(a),a<0||a>=t)throw new Error(`Wrong integer: ${a}`)});;){let a=0,l=!0;for(let c=r;c<s.length;c++){const d=s[c],h=t*a+d;if(!Number.isSafeInteger(h)||t*a/t!==a||h-d!==t*a)throw new Error("convertRadix: carry overflow");if(a=h%n,s[c]=Math.floor(h/n),!Number.isSafeInteger(s[c])||s[c]*n+a!==h)throw new Error("convertRadix: carry overflow");if(l)s[c]?l=!1:r=c;else continue}if(o.push(a),l)break}for(let a=0;a<e.length-1&&e[a]===0;a++)o.push(0);return o.reverse()}const gcd=(e,t)=>t?gcd(t,e%t):e,radix2carry=(e,t)=>e+(t-gcd(e,t));function convertRadix2(e,t,n,r){if(!Array.isArray(e))throw new Error("convertRadix2: data should be array");if(t<=0||t>32)throw new Error(`convertRadix2: wrong from=${t}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(radix2carry(t,n)>32)throw new Error(`convertRadix2: carry overflow from=${t} to=${n} carryBits=${radix2carry(t,n)}`);let o=0,s=0;const a=2**n-1,l=[];for(const c of e){if(assertNumber(c),c>=2**t)throw new Error(`convertRadix2: invalid data word=${c} from=${t}`);if(o=o<<t|c,s+t>32)throw new Error(`convertRadix2: carry overflow pos=${s} from=${t}`);for(s+=t;s>=n;s-=n)l.push((o>>s-n&a)>>>0);o&=2**s-1}if(o=o<<n-s&a,!r&&s>=t)throw new Error("Excess padding");if(!r&&o)throw new Error(`Non-zero padding: ${o}`);return r&&s>0&&l.push(o>>>0),l}function radix(e){return assertNumber(e),{encode:t=>{if(!(t instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return convertRadix(Array.from(t),2**8,e)},decode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(convertRadix(t,e,2**8))}}}function radix2(e,t=!1){if(assertNumber(e),e<=0||e>32)throw new Error("radix2: bits should be in (0..32]");if(radix2carry(8,e)>32||radix2carry(e,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!(n instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return convertRadix2(Array.from(n),8,e,!t)},decode:n=>{if(!Array.isArray(n)||n.length&&typeof n[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(convertRadix2(n,e,8,t))}}}function unsafeWrapper(e){if(typeof e!="function")throw new Error("unsafeWrapper fn should be function");return function(...t){try{return e.apply(null,t)}catch{}}}const base16=chain(radix2(4),alphabet("0123456789ABCDEF"),join("")),base32=chain(radix2(5),alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),padding(5),join(""));chain(radix2(5),alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"),padding(5),join(""));chain(radix2(5),alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),join(""),normalize(e=>e.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1")));const base64=chain(radix2(6),alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),padding(6),join("")),base64url=chain(radix2(6),alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),padding(6),join("")),genBase58=e=>chain(radix(58),alphabet(e),join("")),base58=genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");const XMR_BLOCK_LEN=[0,2,3,5,6,7,9,10,11],base58xmr={encode(e){let t="";for(let n=0;n<e.length;n+=8){const r=e.subarray(n,n+8);t+=base58.encode(r).padStart(XMR_BLOCK_LEN[r.length],"1")}return t},decode(e){let t=[];for(let n=0;n<e.length;n+=11){const r=e.slice(n,n+11),o=XMR_BLOCK_LEN.indexOf(r.length),s=base58.decode(r);for(let a=0;a<s.length-o;a++)if(s[a]!==0)throw new Error("base58xmr: wrong padding");t=t.concat(Array.from(s.slice(s.length-o)))}return Uint8Array.from(t)}},BECH_ALPHABET=chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),join("")),POLYMOD_GENERATORS=[996825010,642813549,513874426,1027748829,705979059];function bech32Polymod(e){const t=e>>25;let n=(e&33554431)<<5;for(let r=0;r<POLYMOD_GENERATORS.length;r++)(t>>r&1)===1&&(n^=POLYMOD_GENERATORS[r]);return n}function bechChecksum(e,t,n=1){const r=e.length;let o=1;for(let s=0;s<r;s++){const a=e.charCodeAt(s);if(a<33||a>126)throw new Error(`Invalid prefix (${e})`);o=bech32Polymod(o)^a>>5}o=bech32Polymod(o);for(let s=0;s<r;s++)o=bech32Polymod(o)^e.charCodeAt(s)&31;for(let s of t)o=bech32Polymod(o)^s;for(let s=0;s<6;s++)o=bech32Polymod(o);return o^=n,BECH_ALPHABET.encode(convertRadix2([o%2**30],30,5,!1))}function genBech32(e){const t=e==="bech32"?1:734539939,n=radix2(5),r=n.decode,o=n.encode,s=unsafeWrapper(r);function a(h,u,m=90){if(typeof h!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof h}`);if(!Array.isArray(u)||u.length&&typeof u[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof u}`);const g=h.length+7+u.length;if(m!==!1&&g>m)throw new TypeError(`Length ${g} exceeds limit ${m}`);return h=h.toLowerCase(),`${h}1${BECH_ALPHABET.encode(u)}${bechChecksum(h,u,t)}`}function l(h,u=90){if(typeof h!="string")throw new Error(`bech32.decode input should be string, not ${typeof h}`);if(h.length<8||u!==!1&&h.length>u)throw new TypeError(`Wrong string length: ${h.length} (${h}). Expected (8..${u})`);const m=h.toLowerCase();if(h!==m&&h!==h.toUpperCase())throw new Error("String must be lowercase or uppercase");h=m;const g=h.lastIndexOf("1");if(g===0||g===-1)throw new Error('Letter "1" must be present between prefix and data only');const y=h.slice(0,g),f=h.slice(g+1);if(f.length<6)throw new Error("Data must be at least 6 characters long");const w=BECH_ALPHABET.decode(f).slice(0,-6),b=bechChecksum(y,w,t);if(!f.endsWith(b))throw new Error(`Invalid checksum in ${h}: expected "${b}"`);return{prefix:y,words:w}}const c=unsafeWrapper(l);function d(h){const{prefix:u,words:m}=l(h,!1);return{prefix:u,words:m,bytes:r(m)}}return{encode:a,decode:l,decodeToBytes:d,decodeUnsafe:c,fromWords:r,fromWordsUnsafe:s,toWords:o}}const bech32=genBech32("bech32");genBech32("bech32m");const utf8={encode:e=>new TextDecoder().decode(e),decode:e=>new TextEncoder().encode(e)},hex=chain(radix2(4),alphabet("0123456789abcdef"),join(""),normalize(e=>{if(typeof e!="string"||e.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`);return e.toLowerCase()})),CODERS={utf8,hex,base16,base32,base64,base64url,base58,base58xmr};`${Object.keys(CODERS).join(", ")}`;function number(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`positive integer expected, not ${e}`)}function bool(e){if(typeof e!="boolean")throw new Error(`boolean expected, not ${e}`)}function isBytes(e){return e instanceof Uint8Array||e!=null&&typeof e=="object"&&e.constructor.name==="Uint8Array"}function bytes(e,...t){if(!isBytes(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */const u32=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4)),isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE)throw new Error("Non little-endian hardware is not supported");function checkOpts(e,t){if(t==null||typeof t!="object")throw new Error("options must be defined");return Object.assign(e,t)}function equalBytes(e,t){if(e.length!==t.length)return!1;let n=0;for(let r=0;r<e.length;r++)n|=e[r]^t[r];return n===0}const wrapCipher=(e,t)=>(Object.assign(t,e),t),BLOCK_SIZE=16,POLY=283;function mul2(e){return e<<1^POLY&-(e>>7)}function mul(e,t){let n=0;for(;t>0;t>>=1)n^=e&-(t&1),e=mul2(e);return n}const sbox=(()=>{let e=new Uint8Array(256);for(let n=0,r=1;n<256;n++,r^=mul2(r))e[n]=r;const t=new Uint8Array(256);t[0]=99;for(let n=0;n<255;n++){let r=e[255-n];r|=r<<8,t[e[n]]=(r^r>>4^r>>5^r>>6^r>>7^99)&255}return t})(),invSbox=sbox.map((e,t)=>sbox.indexOf(t)),rotr32_8=e=>e<<24|e>>>8,rotl32_8=e=>e<<8|e>>>24;function genTtable(e,t){if(e.length!==256)throw new Error("Wrong sbox length");const n=new Uint32Array(256).map((d,h)=>t(e[h])),r=n.map(rotl32_8),o=r.map(rotl32_8),s=o.map(rotl32_8),a=new Uint32Array(256*256),l=new Uint32Array(256*256),c=new Uint16Array(256*256);for(let d=0;d<256;d++)for(let h=0;h<256;h++){const u=d*256+h;a[u]=n[d]^r[h],l[u]=o[d]^s[h],c[u]=e[d]<<8|e[h]}return{sbox:e,sbox2:c,T0:n,T1:r,T2:o,T3:s,T01:a,T23:l}}const tableEncoding=genTtable(sbox,e=>mul(e,3)<<24|e<<16|e<<8|mul(e,2)),tableDecoding=genTtable(invSbox,e=>mul(e,11)<<24|mul(e,13)<<16|mul(e,9)<<8|mul(e,14)),xPowers=(()=>{const e=new Uint8Array(16);for(let t=0,n=1;t<16;t++,n=mul2(n))e[t]=n;return e})();function expandKeyLE(e){bytes(e);const t=e.length;if(![16,24,32].includes(t))throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${t}`);const{sbox2:n}=tableEncoding,r=u32(e),o=r.length,s=l=>applySbox(n,l,l,l,l),a=new Uint32Array(t+28);a.set(r);for(let l=o;l<a.length;l++){let c=a[l-1];l%o===0?c=s(rotr32_8(c))^xPowers[l/o-1]:o>6&&l%o===4&&(c=s(c)),a[l]=a[l-o]^c}return a}function expandKeyDecLE(e){const t=expandKeyLE(e),n=t.slice(),r=t.length,{sbox2:o}=tableEncoding,{T0:s,T1:a,T2:l,T3:c}=tableDecoding;for(let d=0;d<r;d+=4)for(let h=0;h<4;h++)n[d+h]=t[r-d-4+h];t.fill(0);for(let d=4;d<r-4;d++){const h=n[d],u=applySbox(o,h,h,h,h);n[d]=s[u&255]^a[u>>>8&255]^l[u>>>16&255]^c[u>>>24]}return n}function apply0123(e,t,n,r,o,s){return e[n<<8&65280|r>>>8&255]^t[o>>>8&65280|s>>>24&255]}function applySbox(e,t,n,r,o){return e[t&255|n&65280]|e[r>>>16&255|o>>>16&65280]<<16}function encrypt$1(e,t,n,r,o){const{sbox2:s,T01:a,T23:l}=tableEncoding;let c=0;t^=e[c++],n^=e[c++],r^=e[c++],o^=e[c++];const d=e.length/4-2;for(let y=0;y<d;y++){const f=e[c++]^apply0123(a,l,t,n,r,o),w=e[c++]^apply0123(a,l,n,r,o,t),b=e[c++]^apply0123(a,l,r,o,t,n),$=e[c++]^apply0123(a,l,o,t,n,r);t=f,n=w,r=b,o=$}const h=e[c++]^applySbox(s,t,n,r,o),u=e[c++]^applySbox(s,n,r,o,t),m=e[c++]^applySbox(s,r,o,t,n),g=e[c++]^applySbox(s,o,t,n,r);return{s0:h,s1:u,s2:m,s3:g}}function decrypt$1(e,t,n,r,o){const{sbox2:s,T01:a,T23:l}=tableDecoding;let c=0;t^=e[c++],n^=e[c++],r^=e[c++],o^=e[c++];const d=e.length/4-2;for(let y=0;y<d;y++){const f=e[c++]^apply0123(a,l,t,o,r,n),w=e[c++]^apply0123(a,l,n,t,o,r),b=e[c++]^apply0123(a,l,r,n,t,o),$=e[c++]^apply0123(a,l,o,r,n,t);t=f,n=w,r=b,o=$}const h=e[c++]^applySbox(s,t,o,r,n),u=e[c++]^applySbox(s,n,t,o,r),m=e[c++]^applySbox(s,r,n,t,o),g=e[c++]^applySbox(s,o,r,n,t);return{s0:h,s1:u,s2:m,s3:g}}function getDst(e,t){if(!t)return new Uint8Array(e);if(bytes(t),t.length<e)throw new Error(`aes: wrong destination length, expected at least ${e}, got: ${t.length}`);return t}function validateBlockDecrypt(e){if(bytes(e),e.length%BLOCK_SIZE!==0)throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE}`)}function validateBlockEncrypt(e,t,n){let r=e.length;const o=r%BLOCK_SIZE;if(!t&&o!==0)throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");const s=u32(e);if(t){let c=BLOCK_SIZE-o;c||(c=BLOCK_SIZE),r=r+c}const a=getDst(r,n),l=u32(a);return{b:s,o:l,out:a}}function validatePCKS(e,t){if(!t)return e;const n=e.length;if(!n)throw new Error("aes/pcks5: empty ciphertext not allowed");const r=e[n-1];if(r<=0||r>16)throw new Error(`aes/pcks5: wrong padding byte: ${r}`);const o=e.subarray(0,-r);for(let s=0;s<r;s++)if(e[n-s-1]!==r)throw new Error("aes/pcks5: wrong padding");return o}function padPCKS(e){const t=new Uint8Array(16),n=u32(t);t.set(e);const r=BLOCK_SIZE-e.length;for(let o=BLOCK_SIZE-r;o<BLOCK_SIZE;o++)t[o]=r;return n}const cbc=wrapCipher({blockSize:16,nonceLength:16},function(t,n,r={}){bytes(t),bytes(n,16);const o=!r.disablePadding;return{encrypt:(s,a)=>{const l=expandKeyLE(t),{b:c,o:d,out:h}=validateBlockEncrypt(s,o,a),u=u32(n);let m=u[0],g=u[1],y=u[2],f=u[3],w=0;for(;w+4<=c.length;)m^=c[w+0],g^=c[w+1],y^=c[w+2],f^=c[w+3],{s0:m,s1:g,s2:y,s3:f}=encrypt$1(l,m,g,y,f),d[w++]=m,d[w++]=g,d[w++]=y,d[w++]=f;if(o){const b=padPCKS(s.subarray(w*4));m^=b[0],g^=b[1],y^=b[2],f^=b[3],{s0:m,s1:g,s2:y,s3:f}=encrypt$1(l,m,g,y,f),d[w++]=m,d[w++]=g,d[w++]=y,d[w++]=f}return l.fill(0),h},decrypt:(s,a)=>{validateBlockDecrypt(s);const l=expandKeyDecLE(t),c=u32(n),d=getDst(s.length,a),h=u32(s),u=u32(d);let m=c[0],g=c[1],y=c[2],f=c[3];for(let w=0;w+4<=h.length;){const b=m,$=g,x=y,A=f;m=h[w+0],g=h[w+1],y=h[w+2],f=h[w+3];const{s0:T,s1:v,s2:_,s3:S}=decrypt$1(l,m,g,y,f);u[w++]=T^b,u[w++]=v^$,u[w++]=_^x,u[w++]=S^A}return l.fill(0),validatePCKS(d,o)}}}),_utf8ToBytes=e=>Uint8Array.from(e.split("").map(t=>t.charCodeAt(0))),sigma16=_utf8ToBytes("expand 16-byte k"),sigma32=_utf8ToBytes("expand 32-byte k"),sigma16_32=u32(sigma16),sigma32_32=u32(sigma32);sigma32_32.slice();function rotl(e,t){return e<<t|e>>>32-t}function isAligned32(e){return e.byteOffset%4===0}const BLOCK_LEN=64,BLOCK_LEN32=16,MAX_COUNTER=2**32-1,U32_EMPTY=new Uint32Array;function runCipher(e,t,n,r,o,s,a,l){const c=o.length,d=new Uint8Array(BLOCK_LEN),h=u32(d),u=isAligned32(o)&&isAligned32(s),m=u?u32(o):U32_EMPTY,g=u?u32(s):U32_EMPTY;for(let y=0;y<c;a++){if(e(t,n,r,h,a,l),a>=MAX_COUNTER)throw new Error("arx: counter overflow");const f=Math.min(BLOCK_LEN,c-y);if(u&&f===BLOCK_LEN){const w=y/4;if(y%4!==0)throw new Error("arx: invalid block position");for(let b=0,$;b<BLOCK_LEN32;b++)$=w+b,g[$]=m[$]^h[b];y+=BLOCK_LEN;continue}for(let w=0,b;w<f;w++)b=y+w,s[b]=o[b]^d[w];y+=f}}function createCipher(e,t){const{allowShortKeys:n,extendNonceFn:r,counterLength:o,counterRight:s,rounds:a}=checkOpts({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t);if(typeof e!="function")throw new Error("core must be a function");return number(o),number(a),bool(s),bool(n),(l,c,d,h,u=0)=>{bytes(l),bytes(c),bytes(d);const m=d.length;if(h||(h=new Uint8Array(m)),bytes(h),number(u),u<0||u>=MAX_COUNTER)throw new Error("arx: counter overflow");if(h.length<m)throw new Error(`arx: output (${h.length}) is shorter than data (${m})`);const g=[];let y=l.length,f,w;if(y===32)f=l.slice(),g.push(f),w=sigma32_32;else if(y===16&&n)f=new Uint8Array(32),f.set(l),f.set(l,16),w=sigma16_32,g.push(f);else throw new Error(`arx: invalid 32-byte key, got length=${y}`);isAligned32(c)||(c=c.slice(),g.push(c));const b=u32(f);if(r){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");r(w,b,u32(c.subarray(0,16)),b),c=c.subarray(16)}const $=16-o;if($!==c.length)throw new Error(`arx: nonce must be ${$} or 16 bytes`);if($!==12){const A=new Uint8Array(12);A.set(c,s?0:12-c.length),c=A,g.push(c)}const x=u32(c);for(runCipher(e,w,b,x,d,h,u,a);g.length>0;)g.pop().fill(0);return h}}function chachaCore(e,t,n,r,o,s=20){let a=e[0],l=e[1],c=e[2],d=e[3],h=t[0],u=t[1],m=t[2],g=t[3],y=t[4],f=t[5],w=t[6],b=t[7],$=o,x=n[0],A=n[1],T=n[2],v=a,_=l,S=c,U=d,I=h,L=u,P=m,O=g,W=y,E=f,B=w,k=b,R=$,C=x,H=A,M=T;for(let D=0;D<s;D+=2)v=v+I|0,R=rotl(R^v,16),W=W+R|0,I=rotl(I^W,12),v=v+I|0,R=rotl(R^v,8),W=W+R|0,I=rotl(I^W,7),_=_+L|0,C=rotl(C^_,16),E=E+C|0,L=rotl(L^E,12),_=_+L|0,C=rotl(C^_,8),E=E+C|0,L=rotl(L^E,7),S=S+P|0,H=rotl(H^S,16),B=B+H|0,P=rotl(P^B,12),S=S+P|0,H=rotl(H^S,8),B=B+H|0,P=rotl(P^B,7),U=U+O|0,M=rotl(M^U,16),k=k+M|0,O=rotl(O^k,12),U=U+O|0,M=rotl(M^U,8),k=k+M|0,O=rotl(O^k,7),v=v+L|0,M=rotl(M^v,16),B=B+M|0,L=rotl(L^B,12),v=v+L|0,M=rotl(M^v,8),B=B+M|0,L=rotl(L^B,7),_=_+P|0,R=rotl(R^_,16),k=k+R|0,P=rotl(P^k,12),_=_+P|0,R=rotl(R^_,8),k=k+R|0,P=rotl(P^k,7),S=S+O|0,C=rotl(C^S,16),W=W+C|0,O=rotl(O^W,12),S=S+O|0,C=rotl(C^S,8),W=W+C|0,O=rotl(O^W,7),U=U+I|0,H=rotl(H^U,16),E=E+H|0,I=rotl(I^E,12),U=U+I|0,H=rotl(H^U,8),E=E+H|0,I=rotl(I^E,7);let N=0;r[N++]=a+v|0,r[N++]=l+_|0,r[N++]=c+S|0,r[N++]=d+U|0,r[N++]=h+I|0,r[N++]=u+L|0,r[N++]=m+P|0,r[N++]=g+O|0,r[N++]=y+W|0,r[N++]=f+E|0,r[N++]=w+B|0,r[N++]=b+k|0,r[N++]=$+R|0,r[N++]=x+C|0,r[N++]=A+H|0,r[N++]=T+M|0}const chacha20=createCipher(chachaCore,{counterRight:!1,counterLength:4,allowShortKeys:!1});class HMAC extends Hash{constructor(t,n){super(),this.finished=!1,this.destroyed=!1,assert.hash(t);const r=toBytes(n);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?t.create().update(r).digest():r);for(let a=0;a<s.length;a++)s[a]^=54;this.iHash.update(s),this.oHash=t.create();for(let a=0;a<s.length;a++)s[a]^=106;this.oHash.update(s),s.fill(0)}update(t){return assert.exists(this),this.iHash.update(t),this}digestInto(t){assert.exists(this),assert.bytes(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:s,blockLen:a,outputLen:l}=this;return t=t,t.finished=o,t.destroyed=s,t.blockLen=a,t.outputLen=l,t.oHash=n._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const hmac=(e,t,n)=>new HMAC(e,t).update(n).digest();hmac.create=(e,t)=>new HMAC(e,t);function extract(e,t,n){return assert.hash(e),hmac(e,toBytes(n),toBytes(t))}const HKDF_COUNTER=new Uint8Array([0]),EMPTY_BUFFER=new Uint8Array;function expand(e,t,n,r=32){if(assert.hash(e),assert.number(r),r>255*e.outputLen)throw new Error("Length should be <= 255*HashLen");const o=Math.ceil(r/e.outputLen);n===void 0&&(n=EMPTY_BUFFER);const s=new Uint8Array(o*e.outputLen),a=hmac.create(e,t),l=a._cloneInto(),c=new Uint8Array(a.outputLen);for(let d=0;d<o;d++)HKDF_COUNTER[0]=d+1,l.update(d===0?EMPTY_BUFFER:c).update(n).update(HKDF_COUNTER).digestInto(c),s.set(c,e.outputLen*d),a._cloneInto(l);return a.destroy(),l.destroy(),c.fill(0),HKDF_COUNTER.fill(0),s.slice(0,r)}var __defProp=Object.defineProperty,__export=(e,t)=>{for(var n in t)__defProp(e,n,{get:t[n],enumerable:!0})},verifiedSymbol=Symbol("verified"),isRecord=e=>e instanceof Object;function validateEvent(e){if(!isRecord(e)||typeof e.kind!="number"||typeof e.content!="string"||typeof e.created_at!="number"||typeof e.pubkey!="string"||!e.pubkey.match(/^[a-f0-9]{64}$/)||!Array.isArray(e.tags))return!1;for(let t=0;t<e.tags.length;t++){let n=e.tags[t];if(!Array.isArray(n))return!1;for(let r=0;r<n.length;r++)if(typeof n[r]!="string")return!1}return!0}var utils_exports={};__export(utils_exports,{Queue:()=>Queue,QueueNode:()=>QueueNode,binarySearch:()=>binarySearch,bytesToHex:()=>bytesToHex,hexToBytes:()=>hexToBytes,insertEventIntoAscendingList:()=>insertEventIntoAscendingList,insertEventIntoDescendingList:()=>insertEventIntoDescendingList,normalizeURL:()=>normalizeURL,utf8Decoder:()=>utf8Decoder,utf8Encoder:()=>utf8Encoder});var utf8Decoder=new TextDecoder("utf-8"),utf8Encoder=new TextEncoder;function normalizeURL(e){try{e.indexOf("://")===-1&&(e="wss://"+e);let t=new URL(e);return t.pathname=t.pathname.replace(/\/+/g,"/"),t.pathname.endsWith("/")&&(t.pathname=t.pathname.slice(0,-1)),(t.port==="80"&&t.protocol==="ws:"||t.port==="443"&&t.protocol==="wss:")&&(t.port=""),t.searchParams.sort(),t.hash="",t.toString()}catch{throw new Error(`Invalid URL: ${e}`)}}function insertEventIntoDescendingList(e,t){const[n,r]=binarySearch(e,o=>t.id===o.id?0:t.created_at===o.created_at?-1:o.created_at-t.created_at);return r||e.splice(n,0,t),e}function insertEventIntoAscendingList(e,t){const[n,r]=binarySearch(e,o=>t.id===o.id?0:t.created_at===o.created_at?-1:t.created_at-o.created_at);return r||e.splice(n,0,t),e}function binarySearch(e,t){let n=0,r=e.length-1;for(;n<=r;){const o=Math.floor((n+r)/2),s=t(e[o]);if(s===0)return[o,!0];s<0?r=o-1:n=o+1}return[n,!1]}var QueueNode=class{constructor(e){q(this,"value");q(this,"next",null);q(this,"prev",null);this.value=e}},Queue=class{constructor(){q(this,"first");q(this,"last");this.first=null,this.last=null}enqueue(e){const t=new QueueNode(e);return this.last?this.last===this.first?(this.last=t,this.last.prev=this.first,this.first.next=t):(t.prev=this.last,this.last.next=t,this.last=t):(this.first=t,this.last=t),!0}dequeue(){if(!this.first)return null;if(this.first===this.last){const t=this.first;return this.first=null,this.last=null,t.value}const e=this.first;return this.first=e.next,this.first&&(this.first.prev=null),e.value}},JS=class{generateSecretKey(){return schnorr.utils.randomPrivateKey()}getPublicKey(e){return bytesToHex(schnorr.getPublicKey(e))}finalizeEvent(e,t){const n=e;return n.pubkey=bytesToHex(schnorr.getPublicKey(t)),n.id=getEventHash(n),n.sig=bytesToHex(schnorr.sign(getEventHash(n),t)),n[verifiedSymbol]=!0,n}verifyEvent(e){if(typeof e[verifiedSymbol]=="boolean")return e[verifiedSymbol];const t=getEventHash(e);if(t!==e.id)return e[verifiedSymbol]=!1,!1;try{const n=schnorr.verify(e.sig,t,e.pubkey);return e[verifiedSymbol]=n,n}catch{return e[verifiedSymbol]=!1,!1}}};function serializeEvent(e){if(!validateEvent(e))throw new Error("can't serialize event with wrong or missing properties");return JSON.stringify([0,e.pubkey,e.created_at,e.kind,e.tags,e.content])}function getEventHash(e){let t=sha256(utf8Encoder.encode(serializeEvent(e)));return bytesToHex(t)}var i=new JS,generateSecretKey=i.generateSecretKey,getPublicKey=i.getPublicKey,finalizeEvent=i.finalizeEvent,verifyEvent=i.verifyEvent,kinds_exports={};__export(kinds_exports,{Application:()=>Application,BadgeAward:()=>BadgeAward,BadgeDefinition:()=>BadgeDefinition,BlockedRelaysList:()=>BlockedRelaysList,BookmarkList:()=>BookmarkList,Bookmarksets:()=>Bookmarksets,Calendar:()=>Calendar,CalendarEventRSVP:()=>CalendarEventRSVP,ChannelCreation:()=>ChannelCreation,ChannelHideMessage:()=>ChannelHideMessage,ChannelMessage:()=>ChannelMessage,ChannelMetadata:()=>ChannelMetadata,ChannelMuteUser:()=>ChannelMuteUser,ClassifiedListing:()=>ClassifiedListing,ClientAuth:()=>ClientAuth,CommunitiesList:()=>CommunitiesList,CommunityDefinition:()=>CommunityDefinition,CommunityPostApproval:()=>CommunityPostApproval,Contacts:()=>Contacts,CreateOrUpdateProduct:()=>CreateOrUpdateProduct,CreateOrUpdateStall:()=>CreateOrUpdateStall,Curationsets:()=>Curationsets,Date:()=>Date2,DirectMessageRelaysList:()=>DirectMessageRelaysList,DraftClassifiedListing:()=>DraftClassifiedListing,DraftLong:()=>DraftLong,Emojisets:()=>Emojisets,EncryptedDirectMessage:()=>EncryptedDirectMessage,EventDeletion:()=>EventDeletion,FileMetadata:()=>FileMetadata,FileServerPreference:()=>FileServerPreference,Followsets:()=>Followsets,GenericRepost:()=>GenericRepost,Genericlists:()=>Genericlists,GiftWrap:()=>GiftWrap,HTTPAuth:()=>HTTPAuth,Handlerinformation:()=>Handlerinformation,Handlerrecommendation:()=>Handlerrecommendation,Highlights:()=>Highlights,InterestsList:()=>InterestsList,Interestsets:()=>Interestsets,JobFeedback:()=>JobFeedback,JobRequest:()=>JobRequest,JobResult:()=>JobResult,Label:()=>Label,LightningPubRPC:()=>LightningPubRPC,LiveChatMessage:()=>LiveChatMessage,LiveEvent:()=>LiveEvent,LongFormArticle:()=>LongFormArticle,Metadata:()=>Metadata,Mutelist:()=>Mutelist,NWCWalletInfo:()=>NWCWalletInfo,NWCWalletRequest:()=>NWCWalletRequest,NWCWalletResponse:()=>NWCWalletResponse,NostrConnect:()=>NostrConnect,OpenTimestamps:()=>OpenTimestamps,Pinlist:()=>Pinlist,PrivateDirectMessage:()=>PrivateDirectMessage,ProblemTracker:()=>ProblemTracker,ProfileBadges:()=>ProfileBadges,PublicChatsList:()=>PublicChatsList,Reaction:()=>Reaction,RecommendRelay:()=>RecommendRelay,RelayList:()=>RelayList,Relaysets:()=>Relaysets,Report:()=>Report,Reporting:()=>Reporting,Repost:()=>Repost,Seal:()=>Seal,SearchRelaysList:()=>SearchRelaysList,ShortTextNote:()=>ShortTextNote,Time:()=>Time,UserEmojiList:()=>UserEmojiList,UserStatuses:()=>UserStatuses,Zap:()=>Zap,ZapGoal:()=>ZapGoal,ZapRequest:()=>ZapRequest,classifyKind:()=>classifyKind,isAddressableKind:()=>isAddressableKind,isEphemeralKind:()=>isEphemeralKind,isKind:()=>isKind,isRegularKind:()=>isRegularKind,isReplaceableKind:()=>isReplaceableKind});function isRegularKind(e){return 1e3<=e&&e<1e4||[1,2,4,5,6,7,8,16,40,41,42,43,44].includes(e)}function isReplaceableKind(e){return[0,3].includes(e)||1e4<=e&&e<2e4}function isEphemeralKind(e){return 2e4<=e&&e<3e4}function isAddressableKind(e){return 3e4<=e&&e<4e4}function classifyKind(e){return isRegularKind(e)?"regular":isReplaceableKind(e)?"replaceable":isEphemeralKind(e)?"ephemeral":isAddressableKind(e)?"parameterized":"unknown"}function isKind(e,t){const n=t instanceof Array?t:[t];return validateEvent(e)&&n.includes(e.kind)||!1}var Metadata=0,ShortTextNote=1,RecommendRelay=2,Contacts=3,EncryptedDirectMessage=4,EventDeletion=5,Repost=6,Reaction=7,BadgeAward=8,Seal=13,PrivateDirectMessage=14,GenericRepost=16,ChannelCreation=40,ChannelMetadata=41,ChannelMessage=42,ChannelHideMessage=43,ChannelMuteUser=44,OpenTimestamps=1040,GiftWrap=1059,FileMetadata=1063,LiveChatMessage=1311,ProblemTracker=1971,Report=1984,Reporting=1984,Label=1985,CommunityPostApproval=4550,JobRequest=5999,JobResult=6999,JobFeedback=7e3,ZapGoal=9041,ZapRequest=9734,Zap=9735,Highlights=9802,Mutelist=1e4,Pinlist=10001,RelayList=10002,BookmarkList=10003,CommunitiesList=10004,PublicChatsList=10005,BlockedRelaysList=10006,SearchRelaysList=10007,InterestsList=10015,UserEmojiList=10030,DirectMessageRelaysList=10050,FileServerPreference=10096,NWCWalletInfo=13194,LightningPubRPC=21e3,ClientAuth=22242,NWCWalletRequest=23194,NWCWalletResponse=23195,NostrConnect=24133,HTTPAuth=27235,Followsets=3e4,Genericlists=30001,Relaysets=30002,Bookmarksets=30003,Curationsets=30004,ProfileBadges=30008,BadgeDefinition=30009,Interestsets=30015,CreateOrUpdateStall=30017,CreateOrUpdateProduct=30018,LongFormArticle=30023,DraftLong=30024,Emojisets=30030,Application=30078,LiveEvent=30311,UserStatuses=30315,ClassifiedListing=30402,DraftClassifiedListing=30403,Date2=31922,Time=31923,Calendar=31924,CalendarEventRSVP=31925,Handlerrecommendation=31989,Handlerinformation=31990,CommunityDefinition=34550,fakejson_exports={};__export(fakejson_exports,{getHex64:()=>getHex64,getInt:()=>getInt,getSubscriptionId:()=>getSubscriptionId,matchEventId:()=>matchEventId,matchEventKind:()=>matchEventKind,matchEventPubkey:()=>matchEventPubkey});function getHex64(e,t){let n=t.length+3,r=e.indexOf(`"${t}":`)+n,o=e.slice(r).indexOf('"')+r+1;return e.slice(o,o+64)}function getInt(e,t){let n=t.length,r=e.indexOf(`"${t}":`)+n+3,o=e.slice(r),s=Math.min(o.indexOf(","),o.indexOf("}"));return parseInt(o.slice(0,s),10)}function getSubscriptionId(e){let t=e.slice(0,22).indexOf('"EVENT"');if(t===-1)return null;let n=e.slice(t+7+1).indexOf('"');if(n===-1)return null;let r=t+7+1+n,o=e.slice(r+1,80).indexOf('"');if(o===-1)return null;let s=r+1+o;return e.slice(r+1,s)}function matchEventId(e,t){return t===getHex64(e,"id")}function matchEventPubkey(e,t){return t===getHex64(e,"pubkey")}function matchEventKind(e,t){return t===getInt(e,"kind")}var nip42_exports={};__export(nip42_exports,{makeAuthEvent:()=>makeAuthEvent});function makeAuthEvent(e,t){return{kind:ClientAuth,created_at:Math.floor(Date.now()/1e3),tags:[["relay",e],["challenge",t]],content:""}}var _WebSocket;try{_WebSocket=WebSocket}catch{}var _WebSocket2;try{_WebSocket2=WebSocket}catch{}var nip19_exports={};__export(nip19_exports,{BECH32_REGEX:()=>BECH32_REGEX,Bech32MaxSize:()=>Bech32MaxSize,NostrTypeGuard:()=>NostrTypeGuard,decode:()=>decode,decodeNostrURI:()=>decodeNostrURI,encodeBytes:()=>encodeBytes,naddrEncode:()=>naddrEncode,neventEncode:()=>neventEncode,noteEncode:()=>noteEncode,nprofileEncode:()=>nprofileEncode,npubEncode:()=>npubEncode,nsecEncode:()=>nsecEncode});var NostrTypeGuard={isNProfile:e=>/^nprofile1[a-z\d]+$/.test(e||""),isNEvent:e=>/^nevent1[a-z\d]+$/.test(e||""),isNAddr:e=>/^naddr1[a-z\d]+$/.test(e||""),isNSec:e=>/^nsec1[a-z\d]{58}$/.test(e||""),isNPub:e=>/^npub1[a-z\d]{58}$/.test(e||""),isNote:e=>/^note1[a-z\d]+$/.test(e||""),isNcryptsec:e=>/^ncryptsec1[a-z\d]+$/.test(e||"")},Bech32MaxSize=5e3,BECH32_REGEX=/[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;function integerToUint8Array(e){const t=new Uint8Array(4);return t[0]=e>>24&255,t[1]=e>>16&255,t[2]=e>>8&255,t[3]=e&255,t}function decodeNostrURI(e){try{return e.startsWith("nostr:")&&(e=e.substring(6)),decode(e)}catch{return{type:"invalid",data:null}}}function decode(e){var o,s,a,l,c,d,h;let{prefix:t,words:n}=bech32.decode(e,Bech32MaxSize),r=new Uint8Array(bech32.fromWords(n));switch(t){case"nprofile":{let u=parseTLV(r);if(!((o=u[0])!=null&&o[0]))throw new Error("missing TLV 0 for nprofile");if(u[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");return{type:"nprofile",data:{pubkey:bytesToHex(u[0][0]),relays:u[1]?u[1].map(m=>utf8Decoder.decode(m)):[]}}}case"nevent":{let u=parseTLV(r);if(!((s=u[0])!=null&&s[0]))throw new Error("missing TLV 0 for nevent");if(u[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");if(u[2]&&u[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(u[3]&&u[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"nevent",data:{id:bytesToHex(u[0][0]),relays:u[1]?u[1].map(m=>utf8Decoder.decode(m)):[],author:(a=u[2])!=null&&a[0]?bytesToHex(u[2][0]):void 0,kind:(l=u[3])!=null&&l[0]?parseInt(bytesToHex(u[3][0]),16):void 0}}}case"naddr":{let u=parseTLV(r);if(!((c=u[0])!=null&&c[0]))throw new Error("missing TLV 0 for naddr");if(!((d=u[2])!=null&&d[0]))throw new Error("missing TLV 2 for naddr");if(u[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(!((h=u[3])!=null&&h[0]))throw new Error("missing TLV 3 for naddr");if(u[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"naddr",data:{identifier:utf8Decoder.decode(u[0][0]),pubkey:bytesToHex(u[2][0]),kind:parseInt(bytesToHex(u[3][0]),16),relays:u[1]?u[1].map(m=>utf8Decoder.decode(m)):[]}}}case"nsec":return{type:t,data:r};case"npub":case"note":return{type:t,data:bytesToHex(r)};default:throw new Error(`unknown prefix ${t}`)}}function parseTLV(e){let t={},n=e;for(;n.length>0;){let r=n[0],o=n[1],s=n.slice(2,2+o);if(n=n.slice(2+o),s.length<o)throw new Error(`not enough data to read on TLV ${r}`);t[r]=t[r]||[],t[r].push(s)}return t}function nsecEncode(e){return encodeBytes("nsec",e)}function npubEncode(e){return encodeBytes("npub",hexToBytes(e))}function noteEncode(e){return encodeBytes("note",hexToBytes(e))}function encodeBech32(e,t){let n=bech32.toWords(t);return bech32.encode(e,n,Bech32MaxSize)}function encodeBytes(e,t){return encodeBech32(e,t)}function nprofileEncode(e){let t=encodeTLV({0:[hexToBytes(e.pubkey)],1:(e.relays||[]).map(n=>utf8Encoder.encode(n))});return encodeBech32("nprofile",t)}function neventEncode(e){let t;e.kind!==void 0&&(t=integerToUint8Array(e.kind));let n=encodeTLV({0:[hexToBytes(e.id)],1:(e.relays||[]).map(r=>utf8Encoder.encode(r)),2:e.author?[hexToBytes(e.author)]:[],3:t?[new Uint8Array(t)]:[]});return encodeBech32("nevent",n)}function naddrEncode(e){let t=new ArrayBuffer(4);new DataView(t).setUint32(0,e.kind,!1);let n=encodeTLV({0:[utf8Encoder.encode(e.identifier)],1:(e.relays||[]).map(r=>utf8Encoder.encode(r)),2:[hexToBytes(e.pubkey)],3:[new Uint8Array(t)]});return encodeBech32("naddr",n)}function encodeTLV(e){let t=[];return Object.entries(e).reverse().forEach(([n,r])=>{r.forEach(o=>{let s=new Uint8Array(o.length+2);s.set([parseInt(n)],0),s.set([o.length],1),s.set(o,2),t.push(s)})}),concatBytes(...t)}var nip04_exports={};__export(nip04_exports,{decrypt:()=>decrypt,encrypt:()=>encrypt});function encrypt(e,t,n){const r=e instanceof Uint8Array?bytesToHex(e):e,o=secp256k1.getSharedSecret(r,"02"+t),s=getNormalizedX(o);let a=Uint8Array.from(randomBytes(16)),l=utf8Encoder.encode(n),c=cbc(s,a).encrypt(l),d=base64.encode(new Uint8Array(c)),h=base64.encode(new Uint8Array(a.buffer));return`${d}?iv=${h}`}function decrypt(e,t,n){const r=e instanceof Uint8Array?bytesToHex(e):e;let[o,s]=n.split("?iv="),a=secp256k1.getSharedSecret(r,"02"+t),l=getNormalizedX(a),c=base64.decode(s),d=base64.decode(o),h=cbc(l,c).decrypt(d);return utf8Decoder.decode(h)}function getNormalizedX(e){return e.slice(1,33)}var nip05_exports={};__export(nip05_exports,{NIP05_REGEX:()=>NIP05_REGEX,isNip05:()=>isNip05,isValid:()=>isValid,queryProfile:()=>queryProfile,searchDomain:()=>searchDomain,useFetchImplementation:()=>useFetchImplementation});var NIP05_REGEX=/^(?:([\w.+-]+)@)?([\w_-]+(\.[\w_-]+)+)$/,isNip05=e=>NIP05_REGEX.test(e||""),_fetch;try{_fetch=fetch}catch{}function useFetchImplementation(e){_fetch=e}async function searchDomain(e,t=""){try{const n=`https://${e}/.well-known/nostr.json?name=${t}`,r=await _fetch(n,{redirect:"manual"});if(r.status!==200)throw Error("Wrong response code");return(await r.json()).names}catch{return{}}}async function queryProfile(e){var o;const t=e.match(NIP05_REGEX);if(!t)return null;const[,n="_",r]=t;try{const s=`https://${r}/.well-known/nostr.json?name=${n}`,a=await _fetch(s,{redirect:"manual"});if(a.status!==200)throw Error("Wrong response code");const l=await a.json(),c=l.names[n];return c?{pubkey:c,relays:(o=l.relays)==null?void 0:o[c]}:null}catch{return null}}async function isValid(e,t){const n=await queryProfile(t);return n?n.pubkey===e:!1}var nip10_exports={};__export(nip10_exports,{parse:()=>parse});function parse(e){const t={reply:void 0,root:void 0,mentions:[],profiles:[],quotes:[]};let n,r;for(let o=e.tags.length-1;o>=0;o--){const s=e.tags[o];if(s[0]==="e"&&s[1]){const[a,l,c,d,h]=s,u={id:l,relays:c?[c]:[],author:h};if(d==="root"){t.root=u;continue}if(d==="reply"){t.reply=u;continue}if(d==="mention"){t.mentions.push(u);continue}n?r=u:n=u,t.mentions.push(u);continue}if(s[0]==="q"&&s[1]){const[a,l,c]=s;t.quotes.push({id:l,relays:c?[c]:[]})}if(s[0]==="p"&&s[1]){t.profiles.push({pubkey:s[1],relays:s[2]?[s[2]]:[]});continue}}return t.root||(t.root=r||n||t.reply),t.reply||(t.reply=n||t.root),[t.reply,t.root].forEach(o=>{if(!o)return;let s=t.mentions.indexOf(o);if(s!==-1&&t.mentions.splice(s,1),o.author){let a=t.profiles.find(l=>l.pubkey===o.author);a&&a.relays&&(o.relays||(o.relays=[]),a.relays.forEach(l=>{var c;((c=o.relays)==null?void 0:c.indexOf(l))===-1&&o.relays.push(l)}),a.relays=o.relays)}}),t.mentions.forEach(o=>{if(o.author){let s=t.profiles.find(a=>a.pubkey===o.author);s&&s.relays&&(o.relays||(o.relays=[]),s.relays.forEach(a=>{o.relays.indexOf(a)===-1&&o.relays.push(a)}),s.relays=o.relays)}}),t}var nip11_exports={};__export(nip11_exports,{fetchRelayInformation:()=>fetchRelayInformation,useFetchImplementation:()=>useFetchImplementation2});var _fetch2;try{_fetch2=fetch}catch{}function useFetchImplementation2(e){_fetch2=e}async function fetchRelayInformation(e){return await(await fetch(e.replace("ws://","http://").replace("wss://","https://"),{headers:{Accept:"application/nostr+json"}})).json()}var nip13_exports={};__export(nip13_exports,{fastEventHash:()=>fastEventHash,getPow:()=>getPow,minePow:()=>minePow});function getPow(e){let t=0;for(let n=0;n<64;n+=8){const r=parseInt(e.substring(n,n+8),16);if(r===0)t+=32;else{t+=Math.clz32(r);break}}return t}function minePow(e,t){let n=0;const r=e,o=["nonce",n.toString(),t.toString()];for(r.tags.push(o);;){const s=Math.floor(new Date().getTime()/1e3);if(s!==r.created_at&&(n=0,r.created_at=s),o[1]=(++n).toString(),r.id=fastEventHash(r),getPow(r.id)>=t)break}return r}function fastEventHash(e){return bytesToHex(sha256(utf8Encoder.encode(JSON.stringify([0,e.pubkey,e.created_at,e.kind,e.tags,e.content]))))}var nip17_exports={};__export(nip17_exports,{unwrapEvent:()=>unwrapEvent2,unwrapManyEvents:()=>unwrapManyEvents2,wrapEvent:()=>wrapEvent2,wrapManyEvents:()=>wrapManyEvents2});var nip59_exports={};__export(nip59_exports,{createRumor:()=>createRumor,createSeal:()=>createSeal,createWrap:()=>createWrap,unwrapEvent:()=>unwrapEvent,unwrapManyEvents:()=>unwrapManyEvents,wrapEvent:()=>wrapEvent,wrapManyEvents:()=>wrapManyEvents});var nip44_exports={};__export(nip44_exports,{decrypt:()=>decrypt2,encrypt:()=>encrypt2,getConversationKey:()=>getConversationKey,v2:()=>v2});var minPlaintextSize=1,maxPlaintextSize=65535;function getConversationKey(e,t){const n=secp256k1.getSharedSecret(e,"02"+t).subarray(1,33);return extract(sha256,n,"nip44-v2")}function getMessageKeys(e,t){const n=expand(sha256,e,t,76);return{chacha_key:n.subarray(0,32),chacha_nonce:n.subarray(32,44),hmac_key:n.subarray(44,76)}}function calcPaddedLen(e){if(!Number.isSafeInteger(e)||e<1)throw new Error("expected positive integer");if(e<=32)return 32;const t=1<<Math.floor(Math.log2(e-1))+1,n=t<=256?32:t/8;return n*(Math.floor((e-1)/n)+1)}function writeU16BE(e){if(!Number.isSafeInteger(e)||e<minPlaintextSize||e>maxPlaintextSize)throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");const t=new Uint8Array(2);return new DataView(t.buffer).setUint16(0,e,!1),t}function pad(e){const t=utf8Encoder.encode(e),n=t.length,r=writeU16BE(n),o=new Uint8Array(calcPaddedLen(n)-n);return concatBytes(r,t,o)}function unpad(e){const t=new DataView(e.buffer).getUint16(0),n=e.subarray(2,2+t);if(t<minPlaintextSize||t>maxPlaintextSize||n.length!==t||e.length!==2+calcPaddedLen(t))throw new Error("invalid padding");return utf8Decoder.decode(n)}function hmacAad(e,t,n){if(n.length!==32)throw new Error("AAD associated data must be 32 bytes");const r=concatBytes(n,t);return hmac(sha256,e,r)}function decodePayload(e){if(typeof e!="string")throw new Error("payload must be a valid string");const t=e.length;if(t<132||t>87472)throw new Error("invalid payload length: "+t);if(e[0]==="#")throw new Error("unknown encryption version");let n;try{n=base64.decode(e)}catch(s){throw new Error("invalid base64: "+s.message)}const r=n.length;if(r<99||r>65603)throw new Error("invalid data length: "+r);const o=n[0];if(o!==2)throw new Error("unknown encryption version "+o);return{nonce:n.subarray(1,33),ciphertext:n.subarray(33,-32),mac:n.subarray(-32)}}function encrypt2(e,t,n=randomBytes(32)){const{chacha_key:r,chacha_nonce:o,hmac_key:s}=getMessageKeys(t,n),a=pad(e),l=chacha20(r,o,a),c=hmacAad(s,l,n);return base64.encode(concatBytes(new Uint8Array([2]),n,l,c))}function decrypt2(e,t){const{nonce:n,ciphertext:r,mac:o}=decodePayload(e),{chacha_key:s,chacha_nonce:a,hmac_key:l}=getMessageKeys(t,n),c=hmacAad(l,r,n);if(!equalBytes(c,o))throw new Error("invalid MAC");const d=chacha20(s,a,r);return unpad(d)}var v2={utils:{getConversationKey,calcPaddedLen},encrypt:encrypt2,decrypt:decrypt2},TWO_DAYS=2*24*60*60,now=()=>Math.round(Date.now()/1e3),randomNow=()=>Math.round(now()-Math.random()*TWO_DAYS),nip44ConversationKey=(e,t)=>getConversationKey(e,t),nip44Encrypt=(e,t,n)=>encrypt2(JSON.stringify(e),nip44ConversationKey(t,n)),nip44Decrypt=(e,t)=>JSON.parse(decrypt2(e.content,nip44ConversationKey(t,e.pubkey)));function createRumor(e,t){const n={created_at:now(),content:"",tags:[],...e,pubkey:getPublicKey(t)};return n.id=getEventHash(n),n}function createSeal(e,t,n){return finalizeEvent({kind:Seal,content:nip44Encrypt(e,t,n),created_at:randomNow(),tags:[]},t)}function createWrap(e,t){const n=generateSecretKey();return finalizeEvent({kind:GiftWrap,content:nip44Encrypt(e,n,t),created_at:randomNow(),tags:[["p",t]]},n)}function wrapEvent(e,t,n){const r=createRumor(e,t),o=createSeal(r,t,n);return createWrap(o,n)}function wrapManyEvents(e,t,n){if(!n||n.length===0)throw new Error("At least one recipient is required.");const r=getPublicKey(t),o=[wrapEvent(e,t,r)];return n.forEach(s=>{o.push(wrapEvent(e,t,s))}),o}function unwrapEvent(e,t){const n=nip44Decrypt(e,t);return nip44Decrypt(n,t)}function unwrapManyEvents(e,t){let n=[];return e.forEach(r=>{n.push(unwrapEvent(r,t))}),n.sort((r,o)=>r.created_at-o.created_at),n}function createEvent(e,t,n,r){const o={created_at:Math.ceil(Date.now()/1e3),kind:PrivateDirectMessage,tags:[],content:t};return(Array.isArray(e)?e:[e]).forEach(({publicKey:a,relayUrl:l})=>{o.tags.push(l?["p",a,l]:["p",a])}),r&&o.tags.push(["e",r.eventId,r.relayUrl||"","reply"]),n&&o.tags.push(["subject",n]),o}function wrapEvent2(e,t,n,r,o){const s=createEvent(t,n,r,o);return wrapEvent(s,e,t.publicKey)}function wrapManyEvents2(e,t,n,r,o){if(!t||t.length===0)throw new Error("At least one recipient is required.");return[{publicKey:getPublicKey(e)},...t].map(a=>wrapEvent2(e,a,n,r,o))}var unwrapEvent2=unwrapEvent,unwrapManyEvents2=unwrapManyEvents,nip18_exports={};__export(nip18_exports,{finishRepostEvent:()=>finishRepostEvent,getRepostedEvent:()=>getRepostedEvent,getRepostedEventPointer:()=>getRepostedEventPointer});function finishRepostEvent(e,t,n,r){var a;let o;const s=[...e.tags??[],["e",t.id,n],["p",t.pubkey]];return t.kind===ShortTextNote?o=Repost:(o=GenericRepost,s.push(["k",String(t.kind)])),finalizeEvent({kind:o,tags:s,content:e.content===""||(a=t.tags)!=null&&a.find(l=>l[0]==="-")?"":JSON.stringify(t),created_at:e.created_at},r)}function getRepostedEventPointer(e){if(![Repost,GenericRepost].includes(e.kind))return;let t,n;for(let r=e.tags.length-1;r>=0&&(t===void 0||n===void 0);r--){const o=e.tags[r];o.length>=2&&(o[0]==="e"&&t===void 0?t=o:o[0]==="p"&&n===void 0&&(n=o))}if(t!==void 0)return{id:t[1],relays:[t[2],n==null?void 0:n[2]].filter(r=>typeof r=="string"),author:n==null?void 0:n[1]}}function getRepostedEvent(e,{skipVerification:t}={}){const n=getRepostedEventPointer(e);if(n===void 0||e.content==="")return;let r;try{r=JSON.parse(e.content)}catch{return}if(r.id===n.id&&!(!t&&!verifyEvent(r)))return r}var nip21_exports={};__export(nip21_exports,{NOSTR_URI_REGEX:()=>NOSTR_URI_REGEX,parse:()=>parse2,test:()=>test});var NOSTR_URI_REGEX=new RegExp(`nostr:(${BECH32_REGEX.source})`);function test(e){return typeof e=="string"&&new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(e)}function parse2(e){const t=e.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));if(!t)throw new Error(`Invalid Nostr URI: ${e}`);return{uri:t[0],value:t[1],decoded:decode(t[1])}}var nip25_exports={};__export(nip25_exports,{finishReactionEvent:()=>finishReactionEvent,getReactedEventPointer:()=>getReactedEventPointer});function finishReactionEvent(e,t,n){const r=t.tags.filter(o=>o.length>=2&&(o[0]==="e"||o[0]==="p"));return finalizeEvent({...e,kind:Reaction,tags:[...e.tags??[],...r,["e",t.id],["p",t.pubkey]],content:e.content??"+"},n)}function getReactedEventPointer(e){if(e.kind!==Reaction)return;let t,n;for(let r=e.tags.length-1;r>=0&&(t===void 0||n===void 0);r--){const o=e.tags[r];o.length>=2&&(o[0]==="e"&&t===void 0?t=o:o[0]==="p"&&n===void 0&&(n=o))}if(!(t===void 0||n===void 0))return{id:t[1],relays:[t[2],n[2]].filter(r=>r!==void 0),author:n[1]}}var nip27_exports={};__export(nip27_exports,{parse:()=>parse3});var noCharacter=/\W/m,noURLCharacter=/\W |\W$|$|,| /m;function*parse3(e){const t=e.length;let n=0,r=0;for(;r<t;){let o=e.indexOf(":",r);if(o===-1)break;if(e.substring(o-5,o)==="nostr"){const s=e.substring(o+60).match(noCharacter),a=s?o+60+s.index:t;try{let l,{data:c,type:d}=decode(e.substring(o+1,a));switch(d){case"npub":l={pubkey:c};break;case"nsec":case"note":r=a+1;continue;default:l=c}n!==o-5&&(yield{type:"text",text:e.substring(n,o-5)}),yield{type:"reference",pointer:l},r=a,n=r;continue}catch{r=o+1;continue}}else if(e.substring(o-5,o)==="https"||e.substring(o-4,o)==="http"){const s=e.substring(o+4).match(noURLCharacter),a=s?o+4+s.index:t,l=e[o-1]==="s"?5:4;try{let c=new URL(e.substring(o-l,a));if(c.hostname.indexOf(".")===-1)throw new Error("invalid url");if(n!==o-l&&(yield{type:"text",text:e.substring(n,o-l)}),c.pathname.endsWith(".png")||c.pathname.endsWith(".jpg")||c.pathname.endsWith(".jpeg")||c.pathname.endsWith(".gif")||c.pathname.endsWith(".webp")){yield{type:"image",url:c.toString()},r=a,n=r;continue}if(c.pathname.endsWith(".mp4")||c.pathname.endsWith(".avi")||c.pathname.endsWith(".webm")||c.pathname.endsWith(".mkv")){yield{type:"video",url:c.toString()},r=a,n=r;continue}if(c.pathname.endsWith(".mp3")||c.pathname.endsWith(".aac")||c.pathname.endsWith(".ogg")||c.pathname.endsWith(".opus")){yield{type:"audio",url:c.toString()},r=a,n=r;continue}yield{type:"url",url:c.toString()},r=a,n=r;continue}catch{r=a+1;continue}}else if(e.substring(o-3,o)==="wss"||e.substring(o-2,o)==="ws"){const s=e.substring(o+4).match(noURLCharacter),a=s?o+4+s.index:t,l=e[o-1]==="s"?3:2;try{let c=new URL(e.substring(o-l,a));if(c.hostname.indexOf(".")===-1)throw new Error("invalid ws url");n!==o-l&&(yield{type:"text",text:e.substring(n,o-l)}),yield{type:"relay",url:c.toString()},r=a,n=r;continue}catch{r=a+1;continue}}else{r=o+1;continue}}n!==t&&(yield{type:"text",text:e.substring(n)})}var nip28_exports={};__export(nip28_exports,{channelCreateEvent:()=>channelCreateEvent,channelHideMessageEvent:()=>channelHideMessageEvent,channelMessageEvent:()=>channelMessageEvent,channelMetadataEvent:()=>channelMetadataEvent,channelMuteUserEvent:()=>channelMuteUserEvent});var channelCreateEvent=(e,t)=>{let n;if(typeof e.content=="object")n=JSON.stringify(e.content);else if(typeof e.content=="string")n=e.content;else return;return finalizeEvent({kind:ChannelCreation,tags:[...e.tags??[]],content:n,created_at:e.created_at},t)},channelMetadataEvent=(e,t)=>{let n;if(typeof e.content=="object")n=JSON.stringify(e.content);else if(typeof e.content=="string")n=e.content;else return;return finalizeEvent({kind:ChannelMetadata,tags:[["e",e.channel_create_event_id],...e.tags??[]],content:n,created_at:e.created_at},t)},channelMessageEvent=(e,t)=>{const n=[["e",e.channel_create_event_id,e.relay_url,"root"]];return e.reply_to_channel_message_event_id&&n.push(["e",e.reply_to_channel_message_event_id,e.relay_url,"reply"]),finalizeEvent({kind:ChannelMessage,tags:[...n,...e.tags??[]],content:e.content,created_at:e.created_at},t)},channelHideMessageEvent=(e,t)=>{let n;if(typeof e.content=="object")n=JSON.stringify(e.content);else if(typeof e.content=="string")n=e.content;else return;return finalizeEvent({kind:ChannelHideMessage,tags:[["e",e.channel_message_event_id],...e.tags??[]],content:n,created_at:e.created_at},t)},channelMuteUserEvent=(e,t)=>{let n;if(typeof e.content=="object")n=JSON.stringify(e.content);else if(typeof e.content=="string")n=e.content;else return;return finalizeEvent({kind:ChannelMuteUser,tags:[["p",e.pubkey_to_mute],...e.tags??[]],content:n,created_at:e.created_at},t)},nip30_exports={};__export(nip30_exports,{EMOJI_SHORTCODE_REGEX:()=>EMOJI_SHORTCODE_REGEX,matchAll:()=>matchAll,regex:()=>regex,replaceAll:()=>replaceAll});var EMOJI_SHORTCODE_REGEX=/:(\w+):/,regex=()=>new RegExp(`\\B${EMOJI_SHORTCODE_REGEX.source}\\B`,"g");function*matchAll(e){const t=e.matchAll(regex());for(const n of t)try{const[r,o]=n;yield{shortcode:r,name:o,start:n.index,end:n.index+r.length}}catch{}}function replaceAll(e,t){return e.replaceAll(regex(),(n,r)=>t({shortcode:n,name:r}))}var nip39_exports={};__export(nip39_exports,{useFetchImplementation:()=>useFetchImplementation3,validateGithub:()=>validateGithub});var _fetch3;try{_fetch3=fetch}catch{}function useFetchImplementation3(e){_fetch3=e}async function validateGithub(e,t,n){try{return await(await _fetch3(`https://gist.github.com/${t}/${n}/raw`)).text()===`Verifying that I control the following Nostr public key: ${e}`}catch{return!1}}var nip47_exports={};__export(nip47_exports,{makeNwcRequestEvent:()=>makeNwcRequestEvent,parseConnectionString:()=>parseConnectionString});function parseConnectionString(e){const{host:t,pathname:n,searchParams:r}=new URL(e),o=n||t,s=r.get("relay"),a=r.get("secret");if(!o||!s||!a)throw new Error("invalid connection string");return{pubkey:o,relay:s,secret:a}}async function makeNwcRequestEvent(e,t,n){const o=encrypt(t,e,JSON.stringify({method:"pay_invoice",params:{invoice:n}})),s={kind:NWCWalletRequest,created_at:Math.round(Date.now()/1e3),content:o,tags:[["p",e]]};return finalizeEvent(s,t)}var nip54_exports={};__export(nip54_exports,{normalizeIdentifier:()=>normalizeIdentifier});function normalizeIdentifier(e){return e=e.trim().toLowerCase(),e=e.normalize("NFKC"),Array.from(e).map(t=>new RegExp("\\p{Letter}","u").test(t)||new RegExp("\\p{Number}","u").test(t)?t:"-").join("")}var nip57_exports={};__export(nip57_exports,{getSatoshisAmountFromBolt11:()=>getSatoshisAmountFromBolt11,getZapEndpoint:()=>getZapEndpoint,makeZapReceipt:()=>makeZapReceipt,makeZapRequest:()=>makeZapRequest,useFetchImplementation:()=>useFetchImplementation4,validateZapRequest:()=>validateZapRequest});var _fetch4;try{_fetch4=fetch}catch{}function useFetchImplementation4(e){_fetch4=e}async function getZapEndpoint(e){try{let t="",{lud06:n,lud16:r}=JSON.parse(e.content);if(n){let{words:a}=bech32.decode(n,1e3),l=bech32.fromWords(a);t=utf8Decoder.decode(l)}else if(r){let[a,l]=r.split("@");t=new URL(`/.well-known/lnurlp/${a}`,`https://${l}`).toString()}else return null;let s=await(await _fetch4(t)).json();if(s.allowsNostr&&s.nostrPubkey)return s.callback}catch{}return null}function makeZapRequest(e){let t={kind:9734,created_at:Math.round(Date.now()/1e3),content:e.comment||"",tags:[["p","pubkey"in e?e.pubkey:e.event.pubkey],["amount",e.amount.toString()],["relays",...e.relays]]};if("event"in e){if(isReplaceableKind(e.event.kind)){const n=["a",`${e.event.kind}:${e.event.pubkey}:`];t.tags.push(n)}else if(isAddressableKind(e.event.kind)){let n=e.event.tags.find(([o,s])=>o==="d"&&s);if(!n)throw new Error("d tag not found or is empty");const r=["a",`${e.event.kind}:${e.event.pubkey}:${n[1]}`];t.tags.push(r)}t.tags.push(["k",e.event.kind.toString()])}return t}function validateZapRequest(e){let t;try{t=JSON.parse(e)}catch{return"Invalid zap request JSON."}if(!validateEvent(t))return"Zap request is not a valid Nostr event.";if(!verifyEvent(t))return"Invalid signature on zap request.";let n=t.tags.find(([s,a])=>s==="p"&&a);if(!n)return"Zap request doesn't have a 'p' tag.";if(!n[1].match(/^[a-f0-9]{64}$/))return"Zap request 'p' tag is not valid hex.";let r=t.tags.find(([s,a])=>s==="e"&&a);return r&&!r[1].match(/^[a-f0-9]{64}$/)?"Zap request 'e' tag is not valid hex.":t.tags.find(([s,a])=>s==="relays"&&a)?null:"Zap request doesn't have a 'relays' tag."}function makeZapReceipt({zapRequest:e,preimage:t,bolt11:n,paidAt:r}){let o=JSON.parse(e),s=o.tags.filter(([l])=>l==="e"||l==="p"||l==="a"),a={kind:9735,created_at:Math.round(r.getTime()/1e3),content:"",tags:[...s,["P",o.pubkey],["bolt11",n],["description",e]]};return t&&a.tags.push(["preimage",t]),a}function getSatoshisAmountFromBolt11(e){if(e.length<50)return 0;e=e.substring(0,50);const t=e.lastIndexOf("1");if(t===-1)return 0;const n=e.substring(0,t);if(!n.startsWith("lnbc"))return 0;const r=n.substring(4);if(r.length<1)return 0;const o=r[r.length-1],s=o.charCodeAt(0)-48,a=s>=0&&s<=9;let l=r.length-1;if(a&&l++,l<1)return 0;const c=parseInt(r.substring(0,l));switch(o){case"m":return c*1e5;case"u":return c*100;case"n":return c/10;case"p":return c/1e4;default:return c*1e8}}var nip98_exports={};__export(nip98_exports,{getToken:()=>getToken,hashPayload:()=>hashPayload,unpackEventFromToken:()=>unpackEventFromToken,validateEvent:()=>validateEvent2,validateEventKind:()=>validateEventKind,validateEventMethodTag:()=>validateEventMethodTag,validateEventPayloadTag:()=>validateEventPayloadTag,validateEventTimestamp:()=>validateEventTimestamp,validateEventUrlTag:()=>validateEventUrlTag,validateToken:()=>validateToken});var _authorizationScheme="Nostr ";async function getToken(e,t,n,r=!1,o){const s={kind:HTTPAuth,tags:[["u",e],["method",t]],created_at:Math.round(new Date().getTime()/1e3),content:""};o&&s.tags.push(["payload",hashPayload(o)]);const a=await n(s);return(r?_authorizationScheme:"")+base64.encode(utf8Encoder.encode(JSON.stringify(a)))}async function validateToken(e,t,n){const r=await unpackEventFromToken(e).catch(s=>{throw s});return await validateEvent2(r,t,n).catch(s=>{throw s})}async function unpackEventFromToken(e){if(!e)throw new Error("Missing token");e=e.replace(_authorizationScheme,"");const t=utf8Decoder.decode(base64.decode(e));if(!t||t.length===0||!t.startsWith("{"))throw new Error("Invalid token");return JSON.parse(t)}function validateEventTimestamp(e){return e.created_at?Math.round(new Date().getTime()/1e3)-e.created_at<60:!1}function validateEventKind(e){return e.kind===HTTPAuth}function validateEventUrlTag(e,t){const n=e.tags.find(r=>r[0]==="u");return n?n.length>0&&n[1]===t:!1}function validateEventMethodTag(e,t){const n=e.tags.find(r=>r[0]==="method");return n?n.length>0&&n[1].toLowerCase()===t.toLowerCase():!1}function hashPayload(e){const t=sha256(utf8Encoder.encode(JSON.stringify(e)));return bytesToHex(t)}function validateEventPayloadTag(e,t){const n=e.tags.find(o=>o[0]==="payload");if(!n)return!1;const r=hashPayload(t);return n.length>0&&n[1]===r}async function validateEvent2(e,t,n,r){if(!verifyEvent(e))throw new Error("Invalid nostr event, signature invalid");if(!validateEventKind(e))throw new Error("Invalid nostr event, kind invalid");if(!validateEventTimestamp(e))throw new Error("Invalid nostr event, created_at timestamp invalid");if(!validateEventUrlTag(e,t))throw new Error("Invalid nostr event, url tag invalid");if(!validateEventMethodTag(e,n))throw new Error("Invalid nostr event, method tag invalid");if(r&&typeof r=="object"&&Object.keys(r).length>0&&!validateEventPayloadTag(e,r))throw new Error("Invalid nostr event, payload tag does not match request body hash");return!0}function storedKey(e="token"){try{return auth.keyFromNsec(localStorage.getItem(e))}catch{const t=auth.randomKey();return localStorage.setItem(e,t.sec),t}}const auth={keyFromNsec:e=>({pub:getPub(e),sec:e,sign:t=>signEvent(t,e)}),randomKey:()=>{const e=nip19_exports.nsecEncode(generateSecretKey());return auth.keyFromNsec(e)},checkEvent:e=>verifyEvent(e)},bob=auth.keyFromNsec("nsec1qp3y43jmsdr665dc2gxmaxm6e5pqtyhqdr3zsfa902j2vr3tcpysrwnux0");function getPub(e){const t=nip19_exports.decode(e);if(t.type!=="nsec")throw new Error("Invalid secret key");const n=nip19_exports.npubEncode(getPublicKey(t.data));if(n.startsWith("npub1"))return n;throw new Error("Invalid public key")}const signEvent=(e,t)=>{let n={kind:1,tags:[],content:e,created_at:Math.floor(Date.now()/1e3)};return finalizeEvent(n,nip19_exports.decode(t).data)},htmlElement=(e,t,n="",r)=>{const o=document.createElement(e);return o.innerText=t,n&&o.classList.add(...n.split(".").filter(s=>s)),r&&Object.entries(r).forEach(([s,a])=>{s==="parent"&&a.appendChild(o),s==="children"?a.forEach(l=>o.appendChild(l)):s==="eventListeners"?Object.entries(a).forEach(([l,c])=>{o.addEventListener(l,c)}):s==="color"||s==="background"?o.style[s]=a:s==="style"?Object.entries(a).forEach(([l,c])=>{o.style.setProperty(l,c)}):o[s]=a}),o},html=(e,...t)=>{let n="",r=[],o={};for(let s of t)typeof s=="string"?n=s:s instanceof HTMLElement?r.push(s):o={...o,...s};return htmlElement(e,n,"",{...o,children:r})},p=(...e)=>html("p",...e),h1=(...e)=>html("h1",...e),h2=(...e)=>html("h2",...e),div=(...e)=>html("div",...e),button=(...e)=>html("button",...e),popup=e=>{const t=htmlElement("div","","popup-background");return t.appendChild(e),document.body.appendChild(t),t.onclick=()=>{t.remove()},e.classList.add("popup-dialog"),t.appendChild(htmlElement("div","close","popup-close",{onclick:()=>{t.remove()}})),e.onclick=n=>{n.stopPropagation()},()=>t.remove()};class Writable{constructor(t){q(this,"value");q(this,"listeners",[]);this.value=t}get(){return this.value}set(t,n=!1){if(!(!n&&t===this.value)){for(const r of this.listeners)r(t);this.value=t}}update(t,n=!1){const r=t(this.value);this.set(r,n)}subscribe(t){this.listeners.push(t),t(this.value)}subscribeLater(t){this.listeners.push(t)}}class Stored extends Writable{constructor(n,r){localStorage.getItem(n)!==null&&(r=JSON.parse(localStorage.getItem(n)));super(r);q(this,"key");this.key=n}set(n){JSON.stringify(this.get())!==JSON.stringify(n)&&(super.set(n),localStorage.setItem(this.key,JSON.stringify(n)))}}const SHA256=async e=>{const t=await crypto.subtle.digest("SHA-256",new TextEncoder().encode(e));return Array.from(new Uint8Array(t)).map(r=>r.toString(16).padStart(2,"0")).join("")};async function ServerLogin(e,t,n){async function r(s){const a=signEvent(JSON.stringify(s),n.sec),l=await fetch(e,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(a)});if(l.ok)return JSON.parse(await l.json());throw new Error("Failed to send request:"+l.status)}const o=await Box2Serial(t);return await r({pubkey:n.pub,tag:"publish",app:o}),await r({pubkey:n.pub,tag:"host",appHash:o.hash,allowed:!0}),async(s,a,l=null)=>{const c=await lamHash(a,o),d={tag:"call",pubkey:n.pub,appHash:o.hash,lamHash:c,host:s,argument:l};return await r(d)}}const dummyContext={self:"npub1self",other:"npub1other",getTable:(e,t)=>({get:()=>Promise.resolve(t),set:()=>Promise.resolve(),update:()=>Promise.resolve(),delete:()=>Promise.resolve(),other:{get:()=>Promise.resolve(t),set:()=>Promise.resolve(),update:()=>Promise.resolve(),delete:()=>Promise.resolve()}})};function _lamHash(e,t){return SHA256(e+t)}async function lamHash(e,t){const n=await _lamHash(e.toString(),t.hash);if(!Object.values(t.apiHashes).includes(n))throw new Error("illegal lambda");return n}async function Box2Serial(e){const t=e.getCtx.toString(),n=Object.fromEntries(Object.entries(e.api).map(([s,a])=>[s,a.toString()])),r=await SHA256(JSON.stringify({getCtx:t,api:n})),o={};for(const[s,a]of Object.entries(n))o[s]=await _lamHash(a.toString(),r);return{getCtx:t,api:n,hash:r,apiHashes:o}}const msgBox={getCtx:e=>({msgs:e.getTable("msgs",[]),username:e.getTable("username","anonynmous"),followers:e.getTable("followers",[]),follows:e.getTable("follows",[]),add:(t,n)=>t.update(r=>r.includes(n)?r:[...r,n])}),api:{sendMsg:async(e,t)=>{const n={self:e.self,other:e.other,content:t};await e.msgs.update(r=>[...r,n]),await e.msgs.other.update(r=>[...r,n])},seeMsgs:(e,t)=>e.msgs.get(),setUsername:(e,t)=>e.username.set(t),getUsername:(e,t)=>e.username.other.get(),follow:async e=>{await e.add(e.followers.other,e.self),await e.add(e.follows,e.other)},unfollow:async e=>{await e.followers.other.update(t=>t.filter(n=>n!==e.self)),await e.follows.update(t=>t.filter(n=>n!==e.other))},getFollowers:e=>e.followers.other.get(),getFollows:e=>e.follows.other.get()}},key=storedKey();let socialProvider=null;async function doGetSocialProvider(e){const t=new Writable(new Map),n=new Writable(!1),r=new Writable("anonynmous"),o=async l=>{if(t.get().has(l))return t.get().get(l);const c=await a(l,msgBox.api.getUsername);return t.get().set(l,c),t.set(t.get()),c},s=ServerLogin(e,msgBox,bob).then(async l=>{l(bob.pub,msgBox.api.setUsername,"bob"),await l(bob.pub,msgBox.api.getFollowers).then(async c=>{const d=c.map(h=>o(h));await Promise.all(d)})}),a=await ServerLogin(e,msgBox,key);return a(key.pub,msgBox.api.getUsername).then(l=>{r.set(l)}),a(bob.pub,msgBox.api.follow),s.then(()=>{n.set(!0)}),{nameTable:t,getUsername:o,con:a,loaded:n,myname:r}}async function getSocialProvider(e){return socialProvider||(socialProvider=await doGetSocialProvider(e)),socialProvider}function chatView(e){const t=htmlElement("div","");return getSocialProvider(e).then(n=>{const r=htmlElement("h1","Logged in as ");t.appendChild(r);const o=htmlElement("button","","");o.onclick=()=>{const m=htmlElement("div",""),g=popup(m);m.appendChild(htmlElement("h2","Change Username"));const y=htmlElement("input","");y.value=n.myname.get(),y.addEventListener("keydown",async f=>{f.key==="Enter"&&(n.con(key.pub,msgBox.api.setUsername,y.value).then(()=>{n.myname.set(y.value)}),g())}),y.focus(),m.appendChild(y)},r.appendChild(o);const s=new Writable(bob.pub),a=htmlElement("button","chatting with","",{onclick:()=>{const m=htmlElement("div",""),g=popup(m),y=()=>{m.innerHTML="",m.appendChild(htmlElement("h2","active users")),n.nameTable.get().forEach((f,w)=>{const b=htmlElement("p",f,"",{onclick:async()=>{s.set(w),d(),g()}});m.appendChild(b)})};if(y(),!n.loaded.get()){const f=htmlElement("p","loading...","",{style:{color:"gray"}});console.log(f),m.appendChild(f),n.loaded.subscribeLater(()=>{y(),f.remove()})}}});t.appendChild(a),s.subscribe(async m=>{n.getUsername(m).then(g=>{a.innerHTML=`Chatting with ${g}`})});const l=htmlElement("div","");t.appendChild(l);const c=htmlElement("input","");c.setAttribute("type","text"),c.setAttribute("placeholder","Type a message"),t.appendChild(c),n.con(bob.pub,msgBox.api.follow).then(()=>{n.con(bob.pub,msgBox.api.getFollowers).then(m=>{Promise.all(m.map(n.getUsername)).then(()=>{n.loaded.set(!0)})})});const d=()=>n.con(key.pub,msgBox.api.seeMsgs).then(async m=>{l.innerText="";for(let g of m){if(g.self!==s.get()&&g.other!==s.get())continue;const y=await n.getUsername(g.self);l.appendChild(htmlElement("p",`${y}: ${g.content}`))}});n.myname.subscribe(m=>{o.innerHTML=m,n.nameTable.get().set(key.pub,m),n.nameTable.set(n.nameTable.get()),d()});async function h(){const m=c.value;m&&(await n.con(s.get(),msgBox.api.sendMsg,m),d(),c.value="")}const u=htmlElement("button","send");u.onclick=()=>h(),c.addEventListener("keydown",async m=>{m.key==="Enter"&&!m.shiftKey&&(m.preventDefault(),await h())}),t.appendChild(u),d()}),t}const chessCtx=e=>{const t=[[{type:"rook",color:"white"},{type:"knight",color:"white"},{type:"bishop",color:"white"},{type:"queen",color:"white"},{type:"king",color:"white"},{type:"bishop",color:"white"},{type:"knight",color:"white"},{type:"rook",color:"white"}],[{type:"pawn",color:"white"},{type:"pawn",color:"white"},{type:"pawn",color:"white"},{type:"pawn",color:"white"},{type:"pawn",color:"white"},{type:"pawn",color:"white"},{type:"pawn",color:"white"},{type:"pawn",color:"white"}],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[{type:"pawn",color:"black"},{type:"pawn",color:"black"},{type:"pawn",color:"black"},{type:"pawn",color:"black"},{type:"pawn",color:"black"},{type:"pawn",color:"black"},{type:"pawn",color:"black"},{type:"pawn",color:"black"}],[{type:"rook",color:"black"},{type:"knight",color:"black"},{type:"bishop",color:"black"},{type:"queen",color:"black"},{type:"king",color:"black"},{type:"bishop",color:"black"},{type:"knight",color:"black"},{type:"rook",color:"black"}]];function n(g){return[g%10,Math.floor(g/10)]}function r(g){return g[0]+g[1]*10}if(r(n(21))!=21)throw new Error("posVec failed");function o(g){const[y,f]=n(g);return y>=0&&y<8&&f>=0&&f<8}function s(g,y){const[f,w]=n(y);return g[w][f]}function a(g,y,f){const[w,b]=n(y);g[b][w]=f}function l(g,y){for(let f=0;f<8;f++)for(let w=0;w<8;w++){const b=g[f][w];if(b&&b.color===y&&b.type==="king")return f*10+w}return null}function c(g){const y=[10,-10,1,-1],f=[11,-11,9,-9];if(g.type.startsWith("pawnmoved"))return g.color==="white"?[10]:[-10];if(g.type.startsWith("pawn"))return g.color==="white"?[10,20]:[-10,-20];if(g.type.startsWith("knight"))return[12,8,21,19,-12,8,-21,-19];if(g.type.startsWith("bishop"))return f;if(g.type.startsWith("rook"))return y;if(g.type.startsWith("queen")||g.type.startsWith("king"))return f.concat(y);throw new Error("unknown piece type: "+g.type)}function d(g,y){const[f,w]=n(g),[b,$]=y;return r([f+b,w+$])}function h(g,y){var x,A;const f=s(g,y);if(!f)return[];let w=[],b=f.type;const $=c(f);if(b.startsWith("pawn")){w=$.map(v=>y+v).filter(o).filter(v=>s(g,v)==null);const T=f.color=="white"?1:-1;w=w.concat([1,-1].map(v=>d(y,[v,T])).filter(o).filter(v=>{let _=s(g,v);return _?_.color!=f.color:(_=s(g,v-T*10),_&&_.color!=f.color&&_.type=="pawnmoveddouble")}))}else{const T=b.startsWith("rook")||b.startsWith("bishop")||b.startsWith("queen");for(let v of $){let _=y;for(;_=_+v,!!o(_);){const S=s(g,_);if(S){f.color!==S.color&&w.push(_);break}if(w.push(_),!T)break}}b=="king"&&(s(g,y+1)==null&&s(g,y+2)==null&&((x=s(g,y+3))==null?void 0:x.type)=="rook"&&w.push(y+2),s(g,y-1)==null&&s(g,y-2)==null&&((A=s(g,y-4))==null?void 0:A.type)=="rook"&&w.push(y-2))}return w}function u(g,y){return h(g,y)}function m(g,y){if(g.winner!=null)return["game over",g];let f=s(g.board,y.start);if(!f||f.color!==g.turn)return["not your turn",g];if(!u(g.board,y.start).includes(y.end))return["illegal move",g];if((f.type=="pawn"||f.type=="king"||f.type=="rook")&&(f.type+="moved"),f.type=="pawnmoved"&&Math.abs(y.end-y.start)==20&&(f.type="pawnmoveddouble"),f.type.startsWith("pawn")&&y.start%10!=y.end%10&&s(g.board,y.end)==null&&a(g.board,r([y.end%10,Math.floor(y.start/10)]),null),f.type.startsWith("king")){const b=y.start-y.end;b==2&&(a(g.board,y.end+1,{...f,type:"rookmoved"}),a(g.board,y.end-2,null)),b==-2&&(a(g.board,y.end-1,{...f,type:"rookmoved"}),a(g.board,y.end+1,null))}if(a(g.board,y.end,f),f.type.startsWith("pawn")){const b=Math.floor(y.end/10);(b==0||b==7)&&a(g.board,y.end,{...f,type:y.promo})}return a(g.board,y.start,null),g.turn=g.turn==="white"?"black":"white",l(g.board,g.turn)==null&&(g.winner=g.turn==="white"?"black":"white"),["",g]}return{startBoard:t,hosting:e.getTable("hosting",null),playing:e.getTable("playing",null),invites:e.getTable("invites",[]),add:(g,y)=>g.update(f=>f.includes(y)?f:[...f,y]),makeMove:m,getLegalMoves:u}},chessBox={getCtx:chessCtx,api:{getPlaying:async(e,t)=>e.playing.get(),isPlaying:async(e,t)=>!0,sendInvite:async(e,t)=>{await Promise.all([e.add(e.invites.other,e.self),e.invites.set([])])},getInvites:(e,t)=>e.invites.get(),declineInvite:async(e,t)=>{await e.invites.update(n=>n.filter(r=>r!==e.other))},acceptInvite:async(e,t)=>(await e.invites.get()).includes(e.other)?(await Promise.all([e.playing.get(),e.playing.other.get()])).some(o=>o!=null)?["already playing",!1]:(await Promise.all([e.playing.set(e.other),e.playing.other.set(e.self),e.invites.set([]),e.invites.other.set([])]),await e.hosting.set(null),await e.hosting.other.set({white:e.other,black:e.self,board:e.startBoard,turn:"white",winner:null}),["",!0]):["no invite",!1],makeMove:async(e,t)=>{let n=e.hosting,r=await n.get();if(r||(n=e.hosting.other),r=await n.get(),!r)return"no match";let[o,s]=e.makeMove(r,t);return o||(await e.hosting.other.set(s),s.winner&&await Promise.all([e.playing.set(null),e.playing.other.set(null)]),r)},resign:async(e,t)=>{let n=e.hosting;await n.get()||(n=e.hosting.other),await Promise.all([e.playing.set(null),e.playing.other.set(null),n.update(o=>{if(o)return o.winner=o.white==e.self?"black":"white",o})])},getMatch:async e=>{let t=e.hosting,n=await t.get();return n==null&&(t=e.hosting.other,n=await t.get()),n}}},pieceImages={pawn:"p",knight:"N",bishop:"B",rook:"R",queen:"Q",king:"K",kingmoved:"K",rookmoved:"R",pawnmoved:"p",pawnmoveddouble:"p"},chessView=e=>{const t=storedKey(),n=chessCtx(dummyContext);let r=()=>({white:t.pub,black:dummyContext.other,board:n.startBoard,turn:"white",winner:null}),o=new Writable(r());const s=(window.innerWidth<window.innerHeight?window.innerWidth:window.innerHeight)*.6,a=div({class:"chessboard",style:{backgroundColor:"#f0d9b5",width:s+"px",height:s+"px",margin:"auto",position:"relative",cursor:"pointer"}});let l=null,c=async y=>{o.update(f=>n.makeMove(f,y)[1])};const d=y=>{a.innerHTML="";for(let f=0;f<8;f++)for(let w=0;w<8;w++){const b=div({class:"square"});b.style.width=s/8+"px",b.style.height=s/8+"px",a.appendChild(b),b.style.backgroundColor=(w+f)%2===0?"#b58863":"#f0d9b5",l&&l[0]===w&&l[1]===f&&(b.style.backgroundColor=(w+f)%2===0?"#c9b18f":"#ffd7be"),b.style.left=f*s/8+"px",b.style.bottom=w*s/8+"px",b.style.position="absolute",b.onclick=x=>{if(l&&l[0]===w&&l[1]===f)l=null;else{if(l){const A={start:l[0]*10+l[1],end:w*10+f,promo:"queen"};n.getLegalMoves(y.board,A.start).includes(A.end)&&c(A)}l=[w,f]}};const $=y.board[w][f];if($){const x=div(pieceImages[$.type],{class:"piece"});x.style.width=s/8+"px",x.style.height=s/8+"px",x.style.position="absolute",b.appendChild(x),x.style.color=$.color==="white"?"white":"black",x.style.fontWeight="bold",x.style.fontSize=s/8+"px"}}};o.subscribe(y=>{y&&d(y)});const h=new Writable(null),u=p();h.subscribe(y=>{y?u.innerText="Playing against "+y:u.innerText=""});const m=button("resign"),g=div(h1("Chess"),p("Welcome to the chess page"),u,m,a);return Promise.all([ServerLogin(e,chessBox,t),getSocialProvider(e)]).then(async([y,f])=>{console.log(f.myname.get());let w=!1;setInterval(()=>{if(w)return;let x=o.get();if(!x)return;const A=x.white==t.pub?"white":"black";x.turn!==A&&(w=!0,y(t.pub,chessBox.api.getMatch).then(T=>{T.turn===A&&o.set(T),w=!1}))},200);async function b(){const x=await y(t.pub,chessBox.api.getPlaying);if(!x)return;o.set(await y(x,chessBox.api.getMatch));const A=o.get();if(console.log("match",A),!A){h.set(null);return}if(A.winner){popup(div("game over"));return}o.get().white==t.pub,h.set(await f.getUsername(x)),m.onclick=async()=>{await y(x,chessBox.api.resign)},c=async T=>{console.log("move",T);const v=await y(x,chessBox.api.makeMove,T);console.log("resp",v),typeof v=="string"||o.set(v)}}b();async function $(x){if(await y(x,chessBox.api.isPlaying).catch(A=>!1))y(x,chessBox.api.sendInvite),f.con(x,msgBox.api.sendMsg,"I sent you an invitation to play chess"),popup(div("invitation sent!"));else{const A=popup(div(h2("this user doesnt have chess"),button("send them an invite message",{onclick:async()=>{await f.con(x,msgBox.api.sendMsg,"Wanna play chess with me?"),A(),popup(div("message sent!"))}})))}}f.loaded.subscribe(x=>{x&&g.appendChild(div(button("Play against a friend",{onclick:()=>{const A=popup(div(h2("Play against a friend"),(()=>{const T=div();return y(t.pub,chessBox.api.getInvites).then(v=>{T.appendChild(p("Invites:")),v.forEach(_=>{f.getUsername(_).then(S=>{T.appendChild(button(S,{onclick:()=>{y(_,chessBox.api.acceptInvite).then(([U,I])=>{I?(console.log({msg:U}),popup(div("game accepted!")),b()):popup(div(U))})}}))})})}),T})(),p("Select a friend to play against"),...Array.from(f.nameTable.get().entries()).map(([T,v])=>p(button(v,{onclick:()=>{$(T),A()}}))),button("Cancel",{onclick:()=>A()})))}})))})}),g},objectView=(e,t=0)=>{const n=" ".repeat(t);if(t>2)return htmlElement("p","...");if(e==null)return htmlElement("p",n+"null");if(e instanceof Array){const r=htmlElement("div","");for(const o of e)r.appendChild(objectView(o,t+1));return r}if(e instanceof Function)return htmlElement("p",n+e.toString());if(e==null)return htmlElement("p",n+"undefined");if(typeof e=="string")return htmlElement("p",n+e);if(typeof e=="number"||typeof e=="boolean")return htmlElement("p",n+e.toString());if(typeof e=="object"){const r=htmlElement("div","");for(const[o,s]of Object.entries(e).slice(0,10))r.appendChild(htmlElement("p",o)),r.appendChild(objectView(s,t+1));return r}return htmlElement("p","unknown")},fun=cmd=>eval(cmd);function Console(e,t=fun){const n=htmlElement("div","");n.style.textAlign="left",n.style.whiteSpace="pre",n.style.paddingLeft="2em";const r=htmlElement("input","");r.style.position="fixed",r.style.padding="1em",r.style.bottom="0",r.style.zIndex="1000",r.style.width="90%",r.style.left="1%",setTimeout(()=>{r.focus()},100),n.appendChild(r);const o=htmlElement("div","");n.appendChild(o),o.style.paddingBottom="5em";const s=new Stored("cmdhist",[]);let a=-1,l="";r.addEventListener("keydown",d=>{if(d.key==="Enter"){a=-1,s.update(h=>[...h,r.value]),c(">> "+r.value);try{c(t(r.value))}catch(h){console.log(r.value),console.error(h),c(h.message)}r.value=""}if(d.key==="Escape"&&(a=-1,r.value=""),d.key=="ArrowUp"){const h=s.get().filter(m=>m.startsWith(l)),u=h[h.length+a];u&&(r.value=u)}else if(d.key=="ArrowDown"){const h=s.get().filter(m=>m.startsWith(l)),u=h[h.length+a];u&&(r.value=u),a+=1}else l=r.value,a=-1});function c(d){o.appendChild(objectView(d)),setTimeout(()=>{n.scrollTop=n.scrollHeight},100)}return n}const appname="LamBox";document.title=appname;function getLocation(){const e=window.location.pathname.split("/").filter(Boolean),t=e.includes("local"),n=!e.includes(appname);return{serverLocal:t,frontendLocal:n,path:e.filter(r=>r!="local"&&r!=appname)}}let location=getLocation();const serverurl=location.serverLocal?"http://localhost:8080":"https://lambox.chickenkiller.com/",body=document.body,home=()=>htmlElement("div","","",{children:[htmlElement("h1","Home"),htmlElement("p","Welcome to the lambox"),...apps.filter(e=>e.path).map(e=>htmlElement("p","","",{children:[htmlElement("button",e.path,"",{onclick:()=>{route(e.path.split("/"))}})]}))]}),apps=[{init:home,path:"",cache:void 0},{init:chatView,path:"chat",cache:void 0},{init:chessView,path:"chess",cache:void 0},{init:url=>Console(url,cmd=>eval(cmd)),path:"console",cache:void 0}];route(location.path);window.addEventListener("popstate",e=>{location=getLocation(),route(location.path)});function route(e){let t=(location.serverLocal?"local":"")+"/"+(location.frontendLocal?"":appname)+"/"+e.join("/");t=window.location.origin+"/"+t.split("/").filter(Boolean).join("/"),window.history.pushState({},"",t),body.innerHTML="";for(const n of apps)n.path===e.join("/")&&(n.cache||(n.cache=n.init(serverurl)),body.appendChild(n.cache))}
