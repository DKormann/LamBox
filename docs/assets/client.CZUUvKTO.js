var te=Object.defineProperty;var ne=(e,t,n)=>t in e?te(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n;var W=(e,t,n)=>ne(e,typeof t!="symbol"?t+"":t,n);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))r(o);new MutationObserver(o=>{for(const s of o)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&r(a)}).observe(document,{childList:!0,subtree:!0});function n(o){const s={};return o.integrity&&(s.integrity=o.integrity),o.referrerPolicy&&(s.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?s.credentials="include":o.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(o){if(o.ep)return;o.ep=!0;const s=n(o);fetch(o.href,s)}})();function number$2(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`Wrong positive integer: ${e}`)}function bytes$2(e,...t){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(e.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}function hash$1(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number$2(e.outputLen),number$2(e.blockLen)}function exists$1(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function output$1(e,t){bytes$2(e);const n=t.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const crypto$2=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const u8a$2=e=>e instanceof Uint8Array,createView$1=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),rotr$1=(e,t)=>e<<32-t|e>>>t,isLE$2=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE$2)throw new Error("Non little-endian hardware is not supported");function utf8ToBytes$2(e){if(typeof e!="string")throw new Error(`utf8ToBytes expected string, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}function toBytes$1(e){if(typeof e=="string"&&(e=utf8ToBytes$2(e)),!u8a$2(e))throw new Error(`expected Uint8Array, got ${typeof e}`);return e}function concatBytes$2(...e){const t=new Uint8Array(e.reduce((r,o)=>r+o.length,0));let n=0;return e.forEach(r=>{if(!u8a$2(r))throw new Error("Uint8Array expected");t.set(r,n),n+=r.length}),t}let Hash$1=class{clone(){return this._cloneInto()}};function wrapConstructor$1(e){const t=r=>e().update(toBytes$1(r)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function randomBytes$1(e=32){if(crypto$2&&typeof crypto$2.getRandomValues=="function")return crypto$2.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}function setBigUint64$1(e,t,n,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,n,r);const o=BigInt(32),s=BigInt(4294967295),a=Number(n>>o&s),l=Number(n&s),c=r?4:0,f=r?0:4;e.setUint32(t+c,a,r),e.setUint32(t+f,l,r)}let SHA2$1=class extends Hash$1{constructor(t,n,r,o){super(),this.blockLen=t,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=createView$1(this.buffer)}update(t){exists$1(this);const{view:n,buffer:r,blockLen:o}=this;t=toBytes$1(t);const s=t.length;for(let a=0;a<s;){const l=Math.min(o-this.pos,s-a);if(l===o){const c=createView$1(t);for(;o<=s-a;a+=o)this.process(c,a);continue}r.set(t.subarray(a,a+l),this.pos),this.pos+=l,a+=l,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){exists$1(this),output$1(t,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:a}=this;n[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>o-a&&(this.process(r,0),a=0);for(let u=a;u<o;u++)n[u]=0;setBigUint64$1(r,o-8,BigInt(this.length*8),s),this.process(r,0);const l=createView$1(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const f=c/4,p=this.get();if(f>p.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<f;u++)l.setUint32(4*u,p[u],s)}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:a,pos:l}=this;return t.length=o,t.pos=l,t.finished=s,t.destroyed=a,o%n&&t.buffer.set(r),t}};const Chi$1=(e,t,n)=>e&t^~e&n,Maj$1=(e,t,n)=>e&t^e&n^t&n,SHA256_K$1=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV$1=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W$1=new Uint32Array(64);let SHA256$2=class extends SHA2$1{constructor(){super(64,32,8,!1),this.A=IV$1[0]|0,this.B=IV$1[1]|0,this.C=IV$1[2]|0,this.D=IV$1[3]|0,this.E=IV$1[4]|0,this.F=IV$1[5]|0,this.G=IV$1[6]|0,this.H=IV$1[7]|0}get(){const{A:t,B:n,C:r,D:o,E:s,F:a,G:l,H:c}=this;return[t,n,r,o,s,a,l,c]}set(t,n,r,o,s,a,l,c){this.A=t|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=a|0,this.G=l|0,this.H=c|0}process(t,n){for(let u=0;u<16;u++,n+=4)SHA256_W$1[u]=t.getUint32(n,!1);for(let u=16;u<64;u++){const g=SHA256_W$1[u-15],E=SHA256_W$1[u-2],b=rotr$1(g,7)^rotr$1(g,18)^g>>>3,h=rotr$1(E,17)^rotr$1(E,19)^E>>>10;SHA256_W$1[u]=h+SHA256_W$1[u-7]+b+SHA256_W$1[u-16]|0}let{A:r,B:o,C:s,D:a,E:l,F:c,G:f,H:p}=this;for(let u=0;u<64;u++){const g=rotr$1(l,6)^rotr$1(l,11)^rotr$1(l,25),E=p+g+Chi$1(l,c,f)+SHA256_K$1[u]+SHA256_W$1[u]|0,h=(rotr$1(r,2)^rotr$1(r,13)^rotr$1(r,22))+Maj$1(r,o,s)|0;p=f,f=c,c=l,l=a+E|0,a=s,s=o,o=r,r=E+h|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,a=a+this.D|0,l=l+this.E|0,c=c+this.F|0,f=f+this.G|0,p=p+this.H|0,this.set(r,o,s,a,l,c,f,p)}roundClean(){SHA256_W$1.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const sha256$1=wrapConstructor$1(()=>new SHA256$2);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$4=BigInt(0),_1n$4=BigInt(1),_2n$2=BigInt(2),u8a$1=e=>e instanceof Uint8Array,hexes$1=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function bytesToHex$1(e){if(!u8a$1(e))throw new Error("Uint8Array expected");let t="";for(let n=0;n<e.length;n++)t+=hexes$1[e[n]];return t}function numberToHexUnpadded(e){const t=e.toString(16);return t.length&1?`0${t}`:t}function hexToNumber(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);return BigInt(e===""?"0":`0x${e}`)}function hexToBytes$1(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);const t=e.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(t/2);for(let r=0;r<n.length;r++){const o=r*2,s=e.slice(o,o+2),a=Number.parseInt(s,16);if(Number.isNaN(a)||a<0)throw new Error("Invalid byte sequence");n[r]=a}return n}function bytesToNumberBE(e){return hexToNumber(bytesToHex$1(e))}function bytesToNumberLE(e){if(!u8a$1(e))throw new Error("Uint8Array expected");return hexToNumber(bytesToHex$1(Uint8Array.from(e).reverse()))}function numberToBytesBE(e,t){return hexToBytes$1(e.toString(16).padStart(t*2,"0"))}function numberToBytesLE(e,t){return numberToBytesBE(e,t).reverse()}function numberToVarBytesBE(e){return hexToBytes$1(numberToHexUnpadded(e))}function ensureBytes(e,t,n){let r;if(typeof t=="string")try{r=hexToBytes$1(t)}catch(s){throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${s}`)}else if(u8a$1(t))r=Uint8Array.from(t);else throw new Error(`${e} must be hex string or Uint8Array`);const o=r.length;if(typeof n=="number"&&o!==n)throw new Error(`${e} expected ${n} bytes, got ${o}`);return r}function concatBytes$1(...e){const t=new Uint8Array(e.reduce((r,o)=>r+o.length,0));let n=0;return e.forEach(r=>{if(!u8a$1(r))throw new Error("Uint8Array expected");t.set(r,n),n+=r.length}),t}function equalBytes$1(e,t){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function utf8ToBytes$1(e){if(typeof e!="string")throw new Error(`utf8ToBytes expected string, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}function bitLen(e){let t;for(t=0;e>_0n$4;e>>=_1n$4,t+=1);return t}function bitGet(e,t){return e>>BigInt(t)&_1n$4}const bitSet=(e,t,n)=>e|(n?_1n$4:_0n$4)<<BigInt(t),bitMask=e=>(_2n$2<<BigInt(e-1))-_1n$4,u8n=e=>new Uint8Array(e),u8fr=e=>Uint8Array.from(e);function createHmacDrbg(e,t,n){if(typeof e!="number"||e<2)throw new Error("hashLen must be a number");if(typeof t!="number"||t<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=u8n(e),o=u8n(e),s=0;const a=()=>{r.fill(1),o.fill(0),s=0},l=(...u)=>n(o,r,...u),c=(u=u8n())=>{o=l(u8fr([0]),u),r=l(),u.length!==0&&(o=l(u8fr([1]),u),r=l())},f=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const g=[];for(;u<t;){r=l();const E=r.slice();g.push(E),u+=r.length}return concatBytes$1(...g)};return(u,g)=>{a(),c(u);let E;for(;!(E=g(f()));)c();return a(),E}}const validatorFns={bigint:e=>typeof e=="bigint",function:e=>typeof e=="function",boolean:e=>typeof e=="boolean",string:e=>typeof e=="string",stringOrUint8Array:e=>typeof e=="string"||e instanceof Uint8Array,isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>typeof e=="function"&&Number.isSafeInteger(e.outputLen)};function validateObject(e,t,n={}){const r=(o,s,a)=>{const l=validatorFns[s];if(typeof l!="function")throw new Error(`Invalid validator "${s}", expected function`);const c=e[o];if(!(a&&c===void 0)&&!l(c,e))throw new Error(`Invalid param ${String(o)}=${c} (${typeof c}), expected ${s}`)};for(const[o,s]of Object.entries(t))r(o,s,!1);for(const[o,s]of Object.entries(n))r(o,s,!0);return e}const ut=Object.freeze(Object.defineProperty({__proto__:null,bitGet,bitLen,bitMask,bitSet,bytesToHex:bytesToHex$1,bytesToNumberBE,bytesToNumberLE,concatBytes:concatBytes$1,createHmacDrbg,ensureBytes,equalBytes:equalBytes$1,hexToBytes:hexToBytes$1,hexToNumber,numberToBytesBE,numberToBytesLE,numberToHexUnpadded,numberToVarBytesBE,utf8ToBytes:utf8ToBytes$1,validateObject},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$3=BigInt(0),_1n$3=BigInt(1),_2n$1=BigInt(2),_3n$1=BigInt(3),_4n=BigInt(4),_5n=BigInt(5),_8n=BigInt(8);BigInt(9);BigInt(16);function mod(e,t){const n=e%t;return n>=_0n$3?n:t+n}function pow(e,t,n){if(n<=_0n$3||t<_0n$3)throw new Error("Expected power/modulo > 0");if(n===_1n$3)return _0n$3;let r=_1n$3;for(;t>_0n$3;)t&_1n$3&&(r=r*e%n),e=e*e%n,t>>=_1n$3;return r}function pow2(e,t,n){let r=e;for(;t-- >_0n$3;)r*=r,r%=n;return r}function invert(e,t){if(e===_0n$3||t<=_0n$3)throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);let n=mod(e,t),r=t,o=_0n$3,s=_1n$3;for(;n!==_0n$3;){const l=r/n,c=r%n,f=o-s*l;r=n,n=c,o=s,s=f}if(r!==_1n$3)throw new Error("invert: does not exist");return mod(o,t)}function tonelliShanks(e){const t=(e-_1n$3)/_2n$1;let n,r,o;for(n=e-_1n$3,r=0;n%_2n$1===_0n$3;n/=_2n$1,r++);for(o=_2n$1;o<e&&pow(o,t,e)!==e-_1n$3;o++);if(r===1){const a=(e+_1n$3)/_4n;return function(c,f){const p=c.pow(f,a);if(!c.eql(c.sqr(p),f))throw new Error("Cannot find square root");return p}}const s=(n+_1n$3)/_2n$1;return function(l,c){if(l.pow(c,t)===l.neg(l.ONE))throw new Error("Cannot find square root");let f=r,p=l.pow(l.mul(l.ONE,o),n),u=l.pow(c,s),g=l.pow(c,n);for(;!l.eql(g,l.ONE);){if(l.eql(g,l.ZERO))return l.ZERO;let E=1;for(let h=l.sqr(g);E<f&&!l.eql(h,l.ONE);E++)h=l.sqr(h);const b=l.pow(p,_1n$3<<BigInt(f-E-1));p=l.sqr(b),u=l.mul(u,b),g=l.mul(g,p),f=E}return u}}function FpSqrt(e){if(e%_4n===_3n$1){const t=(e+_1n$3)/_4n;return function(r,o){const s=r.pow(o,t);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(e%_8n===_5n){const t=(e-_5n)/_8n;return function(r,o){const s=r.mul(o,_2n$1),a=r.pow(s,t),l=r.mul(o,a),c=r.mul(r.mul(l,_2n$1),a),f=r.mul(l,r.sub(c,r.ONE));if(!r.eql(r.sqr(f),o))throw new Error("Cannot find square root");return f}}return tonelliShanks(e)}const FIELD_FIELDS=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function validateField(e){const t={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=FIELD_FIELDS.reduce((r,o)=>(r[o]="function",r),t);return validateObject(e,n)}function FpPow(e,t,n){if(n<_0n$3)throw new Error("Expected power > 0");if(n===_0n$3)return e.ONE;if(n===_1n$3)return t;let r=e.ONE,o=t;for(;n>_0n$3;)n&_1n$3&&(r=e.mul(r,o)),o=e.sqr(o),n>>=_1n$3;return r}function FpInvertBatch(e,t){const n=new Array(t.length),r=t.reduce((s,a,l)=>e.is0(a)?s:(n[l]=s,e.mul(s,a)),e.ONE),o=e.inv(r);return t.reduceRight((s,a,l)=>e.is0(a)?s:(n[l]=e.mul(s,n[l]),e.mul(s,a)),o),n}function nLength(e,t){const n=t!==void 0?t:e.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function Field(e,t,n=!1,r={}){if(e<=_0n$3)throw new Error(`Expected Field ORDER > 0, got ${e}`);const{nBitLength:o,nByteLength:s}=nLength(e,t);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");const a=FpSqrt(e),l=Object.freeze({ORDER:e,BITS:o,BYTES:s,MASK:bitMask(o),ZERO:_0n$3,ONE:_1n$3,create:c=>mod(c,e),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return _0n$3<=c&&c<e},is0:c=>c===_0n$3,isOdd:c=>(c&_1n$3)===_1n$3,neg:c=>mod(-c,e),eql:(c,f)=>c===f,sqr:c=>mod(c*c,e),add:(c,f)=>mod(c+f,e),sub:(c,f)=>mod(c-f,e),mul:(c,f)=>mod(c*f,e),pow:(c,f)=>FpPow(l,c,f),div:(c,f)=>mod(c*invert(f,e),e),sqrN:c=>c*c,addN:(c,f)=>c+f,subN:(c,f)=>c-f,mulN:(c,f)=>c*f,inv:c=>invert(c,e),sqrt:r.sqrt||(c=>a(l,c)),invertBatch:c=>FpInvertBatch(l,c),cmov:(c,f,p)=>p?f:c,toBytes:c=>n?numberToBytesLE(c,s):numberToBytesBE(c,s),fromBytes:c=>{if(c.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);return n?bytesToNumberLE(c):bytesToNumberBE(c)}});return Object.freeze(l)}function getFieldBytesLength(e){if(typeof e!="bigint")throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function getMinHashLength(e){const t=getFieldBytesLength(e);return t+Math.ceil(t/2)}function mapHashToField(e,t,n=!1){const r=e.length,o=getFieldBytesLength(t),s=getMinHashLength(t);if(r<16||r<s||r>1024)throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);const a=n?bytesToNumberBE(e):bytesToNumberLE(e),l=mod(a,t-_1n$3)+_1n$3;return n?numberToBytesLE(l,o):numberToBytesBE(l,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$2=BigInt(0),_1n$2=BigInt(1);function wNAF(e,t){const n=(o,s)=>{const a=s.negate();return o?a:s},r=o=>{const s=Math.ceil(t/o)+1,a=2**(o-1);return{windows:s,windowSize:a}};return{constTimeNegate:n,unsafeLadder(o,s){let a=e.ZERO,l=o;for(;s>_0n$2;)s&_1n$2&&(a=a.add(l)),l=l.double(),s>>=_1n$2;return a},precomputeWindow(o,s){const{windows:a,windowSize:l}=r(s),c=[];let f=o,p=f;for(let u=0;u<a;u++){p=f,c.push(p);for(let g=1;g<l;g++)p=p.add(f),c.push(p);f=p.double()}return c},wNAF(o,s,a){const{windows:l,windowSize:c}=r(o);let f=e.ZERO,p=e.BASE;const u=BigInt(2**o-1),g=2**o,E=BigInt(o);for(let b=0;b<l;b++){const h=b*c;let d=Number(a&u);a>>=E,d>c&&(d-=g,a+=_1n$2);const y=h,w=h+Math.abs(d)-1,x=b%2!==0,S=d<0;d===0?p=p.add(n(x,s[y])):f=f.add(n(S,s[w]))}return{p:f,f:p}},wNAFCached(o,s,a,l){const c=o._WINDOW_SIZE||1;let f=s.get(o);return f||(f=this.precomputeWindow(o,c),c!==1&&s.set(o,l(f))),this.wNAF(c,f,a)}}}function validateBasic(e){return validateField(e.Fp),validateObject(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...nLength(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function validatePointOpts(e){const t=validateBasic(e);validateObject(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=t;if(n){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}const{bytesToNumberBE:b2n,hexToBytes:h2b}=ut,DER={Err:class extends Error{constructor(t=""){super(t)}},_parseInt(e){const{Err:t}=DER;if(e.length<2||e[0]!==2)throw new t("Invalid signature integer tag");const n=e[1],r=e.subarray(2,n+2);if(!n||r.length!==n)throw new t("Invalid signature integer: wrong length");if(r[0]&128)throw new t("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new t("Invalid signature integer: unnecessary leading zero");return{d:b2n(r),l:e.subarray(n+2)}},toSig(e){const{Err:t}=DER,n=typeof e=="string"?h2b(e):e;if(!(n instanceof Uint8Array))throw new Error("ui8a expected");let r=n.length;if(r<2||n[0]!=48)throw new t("Invalid signature tag");if(n[1]!==r-2)throw new t("Invalid signature: incorrect length");const{d:o,l:s}=DER._parseInt(n.subarray(2)),{d:a,l}=DER._parseInt(s);if(l.length)throw new t("Invalid signature: left bytes after parsing");return{r:o,s:a}},hexFromSig(e){const t=f=>Number.parseInt(f[0],16)&8?"00"+f:f,n=f=>{const p=f.toString(16);return p.length&1?`0${p}`:p},r=t(n(e.s)),o=t(n(e.r)),s=r.length/2,a=o.length/2,l=n(s),c=n(a);return`30${n(a+s+4)}02${c}${o}02${l}${r}`}},_0n$1=BigInt(0),_1n$1=BigInt(1);BigInt(2);const _3n=BigInt(3);BigInt(4);function weierstrassPoints(e){const t=validatePointOpts(e),{Fp:n}=t,r=t.toBytes||((b,h,d)=>{const y=h.toAffine();return concatBytes$1(Uint8Array.from([4]),n.toBytes(y.x),n.toBytes(y.y))}),o=t.fromBytes||(b=>{const h=b.subarray(1),d=n.fromBytes(h.subarray(0,n.BYTES)),y=n.fromBytes(h.subarray(n.BYTES,2*n.BYTES));return{x:d,y}});function s(b){const{a:h,b:d}=t,y=n.sqr(b),w=n.mul(y,b);return n.add(n.add(w,n.mul(b,h)),d)}if(!n.eql(n.sqr(t.Gy),s(t.Gx)))throw new Error("bad generator point: equation left != right");function a(b){return typeof b=="bigint"&&_0n$1<b&&b<t.n}function l(b){if(!a(b))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(b){const{allowedPrivateKeyLengths:h,nByteLength:d,wrapPrivateKey:y,n:w}=t;if(h&&typeof b!="bigint"){if(b instanceof Uint8Array&&(b=bytesToHex$1(b)),typeof b!="string"||!h.includes(b.length))throw new Error("Invalid key");b=b.padStart(d*2,"0")}let x;try{x=typeof b=="bigint"?b:bytesToNumberBE(ensureBytes("private key",b,d))}catch{throw new Error(`private key must be ${d} bytes, hex or bigint, not ${typeof b}`)}return y&&(x=mod(x,w)),l(x),x}const f=new Map;function p(b){if(!(b instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(h,d,y){if(this.px=h,this.py=d,this.pz=y,h==null||!n.isValid(h))throw new Error("x required");if(d==null||!n.isValid(d))throw new Error("y required");if(y==null||!n.isValid(y))throw new Error("z required")}static fromAffine(h){const{x:d,y}=h||{};if(!h||!n.isValid(d)||!n.isValid(y))throw new Error("invalid affine point");if(h instanceof u)throw new Error("projective point not allowed");const w=x=>n.eql(x,n.ZERO);return w(d)&&w(y)?u.ZERO:new u(d,y,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(h){const d=n.invertBatch(h.map(y=>y.pz));return h.map((y,w)=>y.toAffine(d[w])).map(u.fromAffine)}static fromHex(h){const d=u.fromAffine(o(ensureBytes("pointHex",h)));return d.assertValidity(),d}static fromPrivateKey(h){return u.BASE.multiply(c(h))}_setWindowSize(h){this._WINDOW_SIZE=h,f.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:h,y:d}=this.toAffine();if(!n.isValid(h)||!n.isValid(d))throw new Error("bad point: x or y not FE");const y=n.sqr(d),w=s(h);if(!n.eql(y,w))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:h}=this.toAffine();if(n.isOdd)return!n.isOdd(h);throw new Error("Field doesn't support isOdd")}equals(h){p(h);const{px:d,py:y,pz:w}=this,{px:x,py:S,pz:k}=h,_=n.eql(n.mul(d,k),n.mul(x,w)),$=n.eql(n.mul(y,k),n.mul(S,w));return _&&$}negate(){return new u(this.px,n.neg(this.py),this.pz)}double(){const{a:h,b:d}=t,y=n.mul(d,_3n),{px:w,py:x,pz:S}=this;let k=n.ZERO,_=n.ZERO,$=n.ZERO,B=n.mul(w,w),I=n.mul(x,x),L=n.mul(S,S),T=n.mul(w,x);return T=n.add(T,T),$=n.mul(w,S),$=n.add($,$),k=n.mul(h,$),_=n.mul(y,L),_=n.add(k,_),k=n.sub(I,_),_=n.add(I,_),_=n.mul(k,_),k=n.mul(T,k),$=n.mul(y,$),L=n.mul(h,L),T=n.sub(B,L),T=n.mul(h,T),T=n.add(T,$),$=n.add(B,B),B=n.add($,B),B=n.add(B,L),B=n.mul(B,T),_=n.add(_,B),L=n.mul(x,S),L=n.add(L,L),B=n.mul(L,T),k=n.sub(k,B),$=n.mul(L,I),$=n.add($,$),$=n.add($,$),new u(k,_,$)}add(h){p(h);const{px:d,py:y,pz:w}=this,{px:x,py:S,pz:k}=h;let _=n.ZERO,$=n.ZERO,B=n.ZERO;const I=t.a,L=n.mul(t.b,_3n);let T=n.mul(d,x),U=n.mul(y,S),O=n.mul(w,k),M=n.add(d,y),m=n.add(x,S);M=n.mul(M,m),m=n.add(T,U),M=n.sub(M,m),m=n.add(d,w);let v=n.add(x,k);return m=n.mul(m,v),v=n.add(T,O),m=n.sub(m,v),v=n.add(y,w),_=n.add(S,k),v=n.mul(v,_),_=n.add(U,O),v=n.sub(v,_),B=n.mul(I,m),_=n.mul(L,O),B=n.add(_,B),_=n.sub(U,B),B=n.add(U,B),$=n.mul(_,B),U=n.add(T,T),U=n.add(U,T),O=n.mul(I,O),m=n.mul(L,m),U=n.add(U,O),O=n.sub(T,O),O=n.mul(I,O),m=n.add(m,O),T=n.mul(U,m),$=n.add($,T),T=n.mul(v,m),_=n.mul(M,_),_=n.sub(_,T),T=n.mul(M,U),B=n.mul(v,B),B=n.add(B,T),new u(_,$,B)}subtract(h){return this.add(h.negate())}is0(){return this.equals(u.ZERO)}wNAF(h){return E.wNAFCached(this,f,h,d=>{const y=n.invertBatch(d.map(w=>w.pz));return d.map((w,x)=>w.toAffine(y[x])).map(u.fromAffine)})}multiplyUnsafe(h){const d=u.ZERO;if(h===_0n$1)return d;if(l(h),h===_1n$1)return this;const{endo:y}=t;if(!y)return E.unsafeLadder(this,h);let{k1neg:w,k1:x,k2neg:S,k2:k}=y.splitScalar(h),_=d,$=d,B=this;for(;x>_0n$1||k>_0n$1;)x&_1n$1&&(_=_.add(B)),k&_1n$1&&($=$.add(B)),B=B.double(),x>>=_1n$1,k>>=_1n$1;return w&&(_=_.negate()),S&&($=$.negate()),$=new u(n.mul($.px,y.beta),$.py,$.pz),_.add($)}multiply(h){l(h);let d=h,y,w;const{endo:x}=t;if(x){const{k1neg:S,k1:k,k2neg:_,k2:$}=x.splitScalar(d);let{p:B,f:I}=this.wNAF(k),{p:L,f:T}=this.wNAF($);B=E.constTimeNegate(S,B),L=E.constTimeNegate(_,L),L=new u(n.mul(L.px,x.beta),L.py,L.pz),y=B.add(L),w=I.add(T)}else{const{p:S,f:k}=this.wNAF(d);y=S,w=k}return u.normalizeZ([y,w])[0]}multiplyAndAddUnsafe(h,d,y){const w=u.BASE,x=(k,_)=>_===_0n$1||_===_1n$1||!k.equals(w)?k.multiplyUnsafe(_):k.multiply(_),S=x(this,d).add(x(h,y));return S.is0()?void 0:S}toAffine(h){const{px:d,py:y,pz:w}=this,x=this.is0();h==null&&(h=x?n.ONE:n.inv(w));const S=n.mul(d,h),k=n.mul(y,h),_=n.mul(w,h);if(x)return{x:n.ZERO,y:n.ZERO};if(!n.eql(_,n.ONE))throw new Error("invZ was invalid");return{x:S,y:k}}isTorsionFree(){const{h,isTorsionFree:d}=t;if(h===_1n$1)return!0;if(d)return d(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h,clearCofactor:d}=t;return h===_1n$1?this:d?d(u,this):this.multiplyUnsafe(t.h)}toRawBytes(h=!0){return this.assertValidity(),r(u,this,h)}toHex(h=!0){return bytesToHex$1(this.toRawBytes(h))}}u.BASE=new u(t.Gx,t.Gy,n.ONE),u.ZERO=new u(n.ZERO,n.ONE,n.ZERO);const g=t.nBitLength,E=wNAF(u,t.endo?Math.ceil(g/2):g);return{CURVE:t,ProjectivePoint:u,normPrivateKeyToScalar:c,weierstrassEquation:s,isWithinCurveOrder:a}}function validateOpts(e){const t=validateBasic(e);return validateObject(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}function weierstrass(e){const t=validateOpts(e),{Fp:n,n:r}=t,o=n.BYTES+1,s=2*n.BYTES+1;function a(m){return _0n$1<m&&m<n.ORDER}function l(m){return mod(m,r)}function c(m){return invert(m,r)}const{ProjectivePoint:f,normPrivateKeyToScalar:p,weierstrassEquation:u,isWithinCurveOrder:g}=weierstrassPoints({...t,toBytes(m,v,A){const R=v.toAffine(),C=n.toBytes(R.x),H=concatBytes$1;return A?H(Uint8Array.from([v.hasEvenY()?2:3]),C):H(Uint8Array.from([4]),C,n.toBytes(R.y))},fromBytes(m){const v=m.length,A=m[0],R=m.subarray(1);if(v===o&&(A===2||A===3)){const C=bytesToNumberBE(R);if(!a(C))throw new Error("Point is not on curve");const H=u(C);let P=n.sqrt(H);const N=(P&_1n$1)===_1n$1;return(A&1)===1!==N&&(P=n.neg(P)),{x:C,y:P}}else if(v===s&&A===4){const C=n.fromBytes(R.subarray(0,n.BYTES)),H=n.fromBytes(R.subarray(n.BYTES,2*n.BYTES));return{x:C,y:H}}else throw new Error(`Point of length ${v} was invalid. Expected ${o} compressed bytes or ${s} uncompressed bytes`)}}),E=m=>bytesToHex$1(numberToBytesBE(m,t.nByteLength));function b(m){const v=r>>_1n$1;return m>v}function h(m){return b(m)?l(-m):m}const d=(m,v,A)=>bytesToNumberBE(m.slice(v,A));class y{constructor(v,A,R){this.r=v,this.s=A,this.recovery=R,this.assertValidity()}static fromCompact(v){const A=t.nByteLength;return v=ensureBytes("compactSignature",v,A*2),new y(d(v,0,A),d(v,A,2*A))}static fromDER(v){const{r:A,s:R}=DER.toSig(ensureBytes("DER",v));return new y(A,R)}assertValidity(){if(!g(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!g(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(v){return new y(this.r,this.s,v)}recoverPublicKey(v){const{r:A,s:R,recovery:C}=this,H=$(ensureBytes("msgHash",v));if(C==null||![0,1,2,3].includes(C))throw new Error("recovery id invalid");const P=C===2||C===3?A+t.n:A;if(P>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const N=C&1?"03":"02",D=f.fromHex(N+E(P)),q=c(P),j=l(-H*q),J=l(R*q),V=f.BASE.multiplyAndAddUnsafe(D,j,J);if(!V)throw new Error("point at infinify");return V.assertValidity(),V}hasHighS(){return b(this.s)}normalizeS(){return this.hasHighS()?new y(this.r,l(-this.s),this.recovery):this}toDERRawBytes(){return hexToBytes$1(this.toDERHex())}toDERHex(){return DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return hexToBytes$1(this.toCompactHex())}toCompactHex(){return E(this.r)+E(this.s)}}const w={isValidPrivateKey(m){try{return p(m),!0}catch{return!1}},normPrivateKeyToScalar:p,randomPrivateKey:()=>{const m=getMinHashLength(t.n);return mapHashToField(t.randomBytes(m),t.n)},precompute(m=8,v=f.BASE){return v._setWindowSize(m),v.multiply(BigInt(3)),v}};function x(m,v=!0){return f.fromPrivateKey(m).toRawBytes(v)}function S(m){const v=m instanceof Uint8Array,A=typeof m=="string",R=(v||A)&&m.length;return v?R===o||R===s:A?R===2*o||R===2*s:m instanceof f}function k(m,v,A=!0){if(S(m))throw new Error("first arg must be private key");if(!S(v))throw new Error("second arg must be public key");return f.fromHex(v).multiply(p(m)).toRawBytes(A)}const _=t.bits2int||function(m){const v=bytesToNumberBE(m),A=m.length*8-t.nBitLength;return A>0?v>>BigInt(A):v},$=t.bits2int_modN||function(m){return l(_(m))},B=bitMask(t.nBitLength);function I(m){if(typeof m!="bigint")throw new Error("bigint expected");if(!(_0n$1<=m&&m<B))throw new Error(`bigint expected < 2^${t.nBitLength}`);return numberToBytesBE(m,t.nByteLength)}function L(m,v,A=T){if(["recovered","canonical"].some(z=>z in A))throw new Error("sign() legacy options not supported");const{hash:R,randomBytes:C}=t;let{lowS:H,prehash:P,extraEntropy:N}=A;H==null&&(H=!0),m=ensureBytes("msgHash",m),P&&(m=ensureBytes("prehashed msgHash",R(m)));const D=$(m),q=p(v),j=[I(q),I(D)];if(N!=null){const z=N===!0?C(n.BYTES):N;j.push(ensureBytes("extraEntropy",z))}const J=concatBytes$1(...j),V=D;function X(z){const F=_(z);if(!g(F))return;const Y=c(F),G=f.BASE.multiply(F).toAffine(),K=l(G.x);if(K===_0n$1)return;const Z=l(Y*l(V+K*q));if(Z===_0n$1)return;let Q=(G.x===K?0:2)|Number(G.y&_1n$1),ee=Z;return H&&b(Z)&&(ee=h(Z),Q^=1),new y(K,ee,Q)}return{seed:J,k2sig:X}}const T={lowS:t.lowS,prehash:!1},U={lowS:t.lowS,prehash:!1};function O(m,v,A=T){const{seed:R,k2sig:C}=L(m,v,A),H=t;return createHmacDrbg(H.hash.outputLen,H.nByteLength,H.hmac)(R,C)}f.BASE._setWindowSize(8);function M(m,v,A,R=U){var G;const C=m;if(v=ensureBytes("msgHash",v),A=ensureBytes("publicKey",A),"strict"in R)throw new Error("options.strict was renamed to lowS");const{lowS:H,prehash:P}=R;let N,D;try{if(typeof C=="string"||C instanceof Uint8Array)try{N=y.fromDER(C)}catch(K){if(!(K instanceof DER.Err))throw K;N=y.fromCompact(C)}else if(typeof C=="object"&&typeof C.r=="bigint"&&typeof C.s=="bigint"){const{r:K,s:Z}=C;N=new y(K,Z)}else throw new Error("PARSE");D=f.fromHex(A)}catch(K){if(K.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(H&&N.hasHighS())return!1;P&&(v=t.hash(v));const{r:q,s:j}=N,J=$(v),V=c(j),X=l(J*V),z=l(q*V),F=(G=f.BASE.multiplyAndAddUnsafe(D,X,z))==null?void 0:G.toAffine();return F?l(F.x)===q:!1}return{CURVE:t,getPublicKey:x,getSharedSecret:k,sign:O,verify:M,ProjectivePoint:f,Signature:y,utils:w}}let HMAC$1=class extends Hash$1{constructor(t,n){super(),this.finished=!1,this.destroyed=!1,hash$1(t);const r=toBytes$1(n);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?t.create().update(r).digest():r);for(let a=0;a<s.length;a++)s[a]^=54;this.iHash.update(s),this.oHash=t.create();for(let a=0;a<s.length;a++)s[a]^=106;this.oHash.update(s),s.fill(0)}update(t){return exists$1(this),this.iHash.update(t),this}digestInto(t){exists$1(this),bytes$2(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:s,blockLen:a,outputLen:l}=this;return t=t,t.finished=o,t.destroyed=s,t.blockLen=a,t.outputLen=l,t.oHash=n._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const hmac$1=(e,t,n)=>new HMAC$1(e,t).update(n).digest();hmac$1.create=(e,t)=>new HMAC$1(e,t);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function getHash(e){return{hash:e,hmac:(t,...n)=>hmac$1(e,t,concatBytes$2(...n)),randomBytes:randomBytes$1}}function createCurve(e,t){const n=r=>weierstrass({...e,...getHash(r)});return Object.freeze({...n(t),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const secp256k1P=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),secp256k1N=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),_1n=BigInt(1),_2n=BigInt(2),divNearest=(e,t)=>(e+t/_2n)/t;function sqrtMod(e){const t=secp256k1P,n=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),a=BigInt(23),l=BigInt(44),c=BigInt(88),f=e*e*e%t,p=f*f*e%t,u=pow2(p,n,t)*p%t,g=pow2(u,n,t)*p%t,E=pow2(g,_2n,t)*f%t,b=pow2(E,o,t)*E%t,h=pow2(b,s,t)*b%t,d=pow2(h,l,t)*h%t,y=pow2(d,c,t)*d%t,w=pow2(y,l,t)*h%t,x=pow2(w,n,t)*p%t,S=pow2(x,a,t)*b%t,k=pow2(S,r,t)*f%t,_=pow2(k,_2n,t);if(!Fp.eql(Fp.sqr(_),e))throw new Error("Cannot find square root");return _}const Fp=Field(secp256k1P,void 0,void 0,{sqrt:sqrtMod}),secp256k1=createCurve({a:BigInt(0),b:BigInt(7),Fp,n:secp256k1N,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=secp256k1N,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-_1n*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=n,a=BigInt("0x100000000000000000000000000000000"),l=divNearest(s*e,t),c=divNearest(-r*e,t);let f=mod(e-l*n-c*o,t),p=mod(-l*r-c*s,t);const u=f>a,g=p>a;if(u&&(f=t-f),g&&(p=t-p),f>a||p>a)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:u,k1:f,k2neg:g,k2:p}}}},sha256$1),_0n=BigInt(0),fe=e=>typeof e=="bigint"&&_0n<e&&e<secp256k1P,ge=e=>typeof e=="bigint"&&_0n<e&&e<secp256k1N,TAGGED_HASH_PREFIXES={};function taggedHash(e,...t){let n=TAGGED_HASH_PREFIXES[e];if(n===void 0){const r=sha256$1(Uint8Array.from(e,o=>o.charCodeAt(0)));n=concatBytes$1(r,r),TAGGED_HASH_PREFIXES[e]=n}return sha256$1(concatBytes$1(n,...t))}const pointToBytes=e=>e.toRawBytes(!0).slice(1),numTo32b=e=>numberToBytesBE(e,32),modP=e=>mod(e,secp256k1P),modN=e=>mod(e,secp256k1N),Point=secp256k1.ProjectivePoint,GmulAdd=(e,t,n)=>Point.BASE.multiplyAndAddUnsafe(e,t,n);function schnorrGetExtPubKey(e){let t=secp256k1.utils.normPrivateKeyToScalar(e),n=Point.fromPrivateKey(t);return{scalar:n.hasEvenY()?t:modN(-t),bytes:pointToBytes(n)}}function lift_x(e){if(!fe(e))throw new Error("bad x: need 0 < x < p");const t=modP(e*e),n=modP(t*e+BigInt(7));let r=sqrtMod(n);r%_2n!==_0n&&(r=modP(-r));const o=new Point(e,r,_1n);return o.assertValidity(),o}function challenge(...e){return modN(bytesToNumberBE(taggedHash("BIP0340/challenge",...e)))}function schnorrGetPublicKey(e){return schnorrGetExtPubKey(e).bytes}function schnorrSign(e,t,n=randomBytes$1(32)){const r=ensureBytes("message",e),{bytes:o,scalar:s}=schnorrGetExtPubKey(t),a=ensureBytes("auxRand",n,32),l=numTo32b(s^bytesToNumberBE(taggedHash("BIP0340/aux",a))),c=taggedHash("BIP0340/nonce",l,o,r),f=modN(bytesToNumberBE(c));if(f===_0n)throw new Error("sign failed: k is zero");const{bytes:p,scalar:u}=schnorrGetExtPubKey(f),g=challenge(p,o,r),E=new Uint8Array(64);if(E.set(p,0),E.set(numTo32b(modN(u+g*s)),32),!schnorrVerify(E,r,o))throw new Error("sign: Invalid signature produced");return E}function schnorrVerify(e,t,n){const r=ensureBytes("signature",e,64),o=ensureBytes("message",t),s=ensureBytes("publicKey",n,32);try{const a=lift_x(bytesToNumberBE(s)),l=bytesToNumberBE(r.subarray(0,32));if(!fe(l))return!1;const c=bytesToNumberBE(r.subarray(32,64));if(!ge(c))return!1;const f=challenge(numTo32b(l),pointToBytes(a),o),p=GmulAdd(a,c,modN(-f));return!(!p||!p.hasEvenY()||p.toAffine().x!==l)}catch{return!1}}const schnorr={getPublicKey:schnorrGetPublicKey,sign:schnorrSign,verify:schnorrVerify,utils:{randomPrivateKey:secp256k1.utils.randomPrivateKey,lift_x,pointToBytes,numberToBytesBE,bytesToNumberBE,taggedHash,mod}},crypto$1=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const u8a=e=>e instanceof Uint8Array,createView=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),rotr=(e,t)=>e<<32-t|e>>>t,isLE$1=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE$1)throw new Error("Non little-endian hardware is not supported");const hexes=Array.from({length:256},(e,t)=>t.toString(16).padStart(2,"0"));function bytesToHex(e){if(!u8a(e))throw new Error("Uint8Array expected");let t="";for(let n=0;n<e.length;n++)t+=hexes[e[n]];return t}function hexToBytes(e){if(typeof e!="string")throw new Error("hex string expected, got "+typeof e);const t=e.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const n=new Uint8Array(t/2);for(let r=0;r<n.length;r++){const o=r*2,s=e.slice(o,o+2),a=Number.parseInt(s,16);if(Number.isNaN(a)||a<0)throw new Error("Invalid byte sequence");n[r]=a}return n}function utf8ToBytes(e){if(typeof e!="string")throw new Error(`utf8ToBytes expected string, got ${typeof e}`);return new Uint8Array(new TextEncoder().encode(e))}function toBytes(e){if(typeof e=="string"&&(e=utf8ToBytes(e)),!u8a(e))throw new Error(`expected Uint8Array, got ${typeof e}`);return e}function concatBytes(...e){const t=new Uint8Array(e.reduce((r,o)=>r+o.length,0));let n=0;return e.forEach(r=>{if(!u8a(r))throw new Error("Uint8Array expected");t.set(r,n),n+=r.length}),t}class Hash{clone(){return this._cloneInto()}}function wrapConstructor(e){const t=r=>e().update(toBytes(r)).digest(),n=e();return t.outputLen=n.outputLen,t.blockLen=n.blockLen,t.create=()=>e(),t}function randomBytes(e=32){if(crypto$1&&typeof crypto$1.getRandomValues=="function")return crypto$1.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}function number$1(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`Wrong positive integer: ${e}`)}function bool$1(e){if(typeof e!="boolean")throw new Error(`Expected boolean, not ${e}`)}function bytes$1(e,...t){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(e.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}function hash(e){if(typeof e!="function"||typeof e.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number$1(e.outputLen),number$1(e.blockLen)}function exists(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function output(e,t){bytes$1(e);const n=t.outputLen;if(e.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const assert={number:number$1,bool:bool$1,bytes:bytes$1,hash,exists,output};function setBigUint64(e,t,n,r){if(typeof e.setBigUint64=="function")return e.setBigUint64(t,n,r);const o=BigInt(32),s=BigInt(4294967295),a=Number(n>>o&s),l=Number(n&s),c=r?4:0,f=r?0:4;e.setUint32(t+c,a,r),e.setUint32(t+f,l,r)}class SHA2 extends Hash{constructor(t,n,r,o){super(),this.blockLen=t,this.outputLen=n,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=createView(this.buffer)}update(t){assert.exists(this);const{view:n,buffer:r,blockLen:o}=this;t=toBytes(t);const s=t.length;for(let a=0;a<s;){const l=Math.min(o-this.pos,s-a);if(l===o){const c=createView(t);for(;o<=s-a;a+=o)this.process(c,a);continue}r.set(t.subarray(a,a+l),this.pos),this.pos+=l,a+=l,this.pos===o&&(this.process(n,0),this.pos=0)}return this.length+=t.length,this.roundClean(),this}digestInto(t){assert.exists(this),assert.output(t,this),this.finished=!0;const{buffer:n,view:r,blockLen:o,isLE:s}=this;let{pos:a}=this;n[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>o-a&&(this.process(r,0),a=0);for(let u=a;u<o;u++)n[u]=0;setBigUint64(r,o-8,BigInt(this.length*8),s),this.process(r,0);const l=createView(t),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const f=c/4,p=this.get();if(f>p.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<f;u++)l.setUint32(4*u,p[u],s)}digest(){const{buffer:t,outputLen:n}=this;this.digestInto(t);const r=t.slice(0,n);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:n,buffer:r,length:o,finished:s,destroyed:a,pos:l}=this;return t.length=o,t.pos=l,t.finished=s,t.destroyed=a,o%n&&t.buffer.set(r),t}}const Chi=(e,t,n)=>e&t^~e&n,Maj=(e,t,n)=>e&t^e&n^t&n,SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W=new Uint32Array(64);let SHA256$1=class extends SHA2{constructor(){super(64,32,8,!1),this.A=IV[0]|0,this.B=IV[1]|0,this.C=IV[2]|0,this.D=IV[3]|0,this.E=IV[4]|0,this.F=IV[5]|0,this.G=IV[6]|0,this.H=IV[7]|0}get(){const{A:t,B:n,C:r,D:o,E:s,F:a,G:l,H:c}=this;return[t,n,r,o,s,a,l,c]}set(t,n,r,o,s,a,l,c){this.A=t|0,this.B=n|0,this.C=r|0,this.D=o|0,this.E=s|0,this.F=a|0,this.G=l|0,this.H=c|0}process(t,n){for(let u=0;u<16;u++,n+=4)SHA256_W[u]=t.getUint32(n,!1);for(let u=16;u<64;u++){const g=SHA256_W[u-15],E=SHA256_W[u-2],b=rotr(g,7)^rotr(g,18)^g>>>3,h=rotr(E,17)^rotr(E,19)^E>>>10;SHA256_W[u]=h+SHA256_W[u-7]+b+SHA256_W[u-16]|0}let{A:r,B:o,C:s,D:a,E:l,F:c,G:f,H:p}=this;for(let u=0;u<64;u++){const g=rotr(l,6)^rotr(l,11)^rotr(l,25),E=p+g+Chi(l,c,f)+SHA256_K[u]+SHA256_W[u]|0,h=(rotr(r,2)^rotr(r,13)^rotr(r,22))+Maj(r,o,s)|0;p=f,f=c,c=l,l=a+E|0,a=s,s=o,o=r,r=E+h|0}r=r+this.A|0,o=o+this.B|0,s=s+this.C|0,a=a+this.D|0,l=l+this.E|0,c=c+this.F|0,f=f+this.G|0,p=p+this.H|0,this.set(r,o,s,a,l,c,f,p)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};class SHA224 extends SHA256$1{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const sha256=wrapConstructor(()=>new SHA256$1);wrapConstructor(()=>new SHA224);/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function assertNumber(e){if(!Number.isSafeInteger(e))throw new Error(`Wrong integer: ${e}`)}function chain(...e){const t=(o,s)=>a=>o(s(a)),n=Array.from(e).reverse().reduce((o,s)=>o?t(o,s.encode):s.encode,void 0),r=e.reduce((o,s)=>o?t(o,s.decode):s.decode,void 0);return{encode:n,decode:r}}function alphabet(e){return{encode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return t.map(n=>{if(assertNumber(n),n<0||n>=e.length)throw new Error(`Digit index outside alphabet: ${n} (alphabet: ${e.length})`);return e[n]})},decode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="string")throw new Error("alphabet.decode input should be array of strings");return t.map(n=>{if(typeof n!="string")throw new Error(`alphabet.decode: not string element=${n}`);const r=e.indexOf(n);if(r===-1)throw new Error(`Unknown letter: "${n}". Allowed: ${e}`);return r})}}}function join(e=""){if(typeof e!="string")throw new Error("join separator should be string");return{encode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="string")throw new Error("join.encode input should be array of strings");for(let n of t)if(typeof n!="string")throw new Error(`join.encode: non-string input=${n}`);return t.join(e)},decode:t=>{if(typeof t!="string")throw new Error("join.decode input should be string");return t.split(e)}}}function padding(e,t="="){if(assertNumber(e),typeof t!="string")throw new Error("padding chr should be string");return{encode(n){if(!Array.isArray(n)||n.length&&typeof n[0]!="string")throw new Error("padding.encode input should be array of strings");for(let r of n)if(typeof r!="string")throw new Error(`padding.encode: non-string input=${r}`);for(;n.length*e%8;)n.push(t);return n},decode(n){if(!Array.isArray(n)||n.length&&typeof n[0]!="string")throw new Error("padding.encode input should be array of strings");for(let o of n)if(typeof o!="string")throw new Error(`padding.decode: non-string input=${o}`);let r=n.length;if(r*e%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;r>0&&n[r-1]===t;r--)if(!((r-1)*e%8))throw new Error("Invalid padding: string has too much padding");return n.slice(0,r)}}}function normalize(e){if(typeof e!="function")throw new Error("normalize fn should be function");return{encode:t=>t,decode:t=>e(t)}}function convertRadix(e,t,n){if(t<2)throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: wrong to=${n}, base cannot be less than 2`);if(!Array.isArray(e))throw new Error("convertRadix: data should be array");if(!e.length)return[];let r=0;const o=[],s=Array.from(e);for(s.forEach(a=>{if(assertNumber(a),a<0||a>=t)throw new Error(`Wrong integer: ${a}`)});;){let a=0,l=!0;for(let c=r;c<s.length;c++){const f=s[c],p=t*a+f;if(!Number.isSafeInteger(p)||t*a/t!==a||p-f!==t*a)throw new Error("convertRadix: carry overflow");if(a=p%n,s[c]=Math.floor(p/n),!Number.isSafeInteger(s[c])||s[c]*n+a!==p)throw new Error("convertRadix: carry overflow");if(l)s[c]?l=!1:r=c;else continue}if(o.push(a),l)break}for(let a=0;a<e.length-1&&e[a]===0;a++)o.push(0);return o.reverse()}const gcd=(e,t)=>t?gcd(t,e%t):e,radix2carry=(e,t)=>e+(t-gcd(e,t));function convertRadix2(e,t,n,r){if(!Array.isArray(e))throw new Error("convertRadix2: data should be array");if(t<=0||t>32)throw new Error(`convertRadix2: wrong from=${t}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(radix2carry(t,n)>32)throw new Error(`convertRadix2: carry overflow from=${t} to=${n} carryBits=${radix2carry(t,n)}`);let o=0,s=0;const a=2**n-1,l=[];for(const c of e){if(assertNumber(c),c>=2**t)throw new Error(`convertRadix2: invalid data word=${c} from=${t}`);if(o=o<<t|c,s+t>32)throw new Error(`convertRadix2: carry overflow pos=${s} from=${t}`);for(s+=t;s>=n;s-=n)l.push((o>>s-n&a)>>>0);o&=2**s-1}if(o=o<<n-s&a,!r&&s>=t)throw new Error("Excess padding");if(!r&&o)throw new Error(`Non-zero padding: ${o}`);return r&&s>0&&l.push(o>>>0),l}function radix(e){return assertNumber(e),{encode:t=>{if(!(t instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return convertRadix(Array.from(t),2**8,e)},decode:t=>{if(!Array.isArray(t)||t.length&&typeof t[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(convertRadix(t,e,2**8))}}}function radix2(e,t=!1){if(assertNumber(e),e<=0||e>32)throw new Error("radix2: bits should be in (0..32]");if(radix2carry(8,e)>32||radix2carry(e,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!(n instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return convertRadix2(Array.from(n),8,e,!t)},decode:n=>{if(!Array.isArray(n)||n.length&&typeof n[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(convertRadix2(n,e,8,t))}}}function unsafeWrapper(e){if(typeof e!="function")throw new Error("unsafeWrapper fn should be function");return function(...t){try{return e.apply(null,t)}catch{}}}const base16=chain(radix2(4),alphabet("0123456789ABCDEF"),join("")),base32=chain(radix2(5),alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),padding(5),join(""));chain(radix2(5),alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"),padding(5),join(""));chain(radix2(5),alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),join(""),normalize(e=>e.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1")));const base64=chain(radix2(6),alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),padding(6),join("")),base64url=chain(radix2(6),alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),padding(6),join("")),genBase58=e=>chain(radix(58),alphabet(e),join("")),base58=genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");const XMR_BLOCK_LEN=[0,2,3,5,6,7,9,10,11],base58xmr={encode(e){let t="";for(let n=0;n<e.length;n+=8){const r=e.subarray(n,n+8);t+=base58.encode(r).padStart(XMR_BLOCK_LEN[r.length],"1")}return t},decode(e){let t=[];for(let n=0;n<e.length;n+=11){const r=e.slice(n,n+11),o=XMR_BLOCK_LEN.indexOf(r.length),s=base58.decode(r);for(let a=0;a<s.length-o;a++)if(s[a]!==0)throw new Error("base58xmr: wrong padding");t=t.concat(Array.from(s.slice(s.length-o)))}return Uint8Array.from(t)}},BECH_ALPHABET=chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),join("")),POLYMOD_GENERATORS=[996825010,642813549,513874426,1027748829,705979059];function bech32Polymod(e){const t=e>>25;let n=(e&33554431)<<5;for(let r=0;r<POLYMOD_GENERATORS.length;r++)(t>>r&1)===1&&(n^=POLYMOD_GENERATORS[r]);return n}function bechChecksum(e,t,n=1){const r=e.length;let o=1;for(let s=0;s<r;s++){const a=e.charCodeAt(s);if(a<33||a>126)throw new Error(`Invalid prefix (${e})`);o=bech32Polymod(o)^a>>5}o=bech32Polymod(o);for(let s=0;s<r;s++)o=bech32Polymod(o)^e.charCodeAt(s)&31;for(let s of t)o=bech32Polymod(o)^s;for(let s=0;s<6;s++)o=bech32Polymod(o);return o^=n,BECH_ALPHABET.encode(convertRadix2([o%2**30],30,5,!1))}function genBech32(e){const t=e==="bech32"?1:734539939,n=radix2(5),r=n.decode,o=n.encode,s=unsafeWrapper(r);function a(p,u,g=90){if(typeof p!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof p}`);if(!Array.isArray(u)||u.length&&typeof u[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof u}`);const E=p.length+7+u.length;if(g!==!1&&E>g)throw new TypeError(`Length ${E} exceeds limit ${g}`);return p=p.toLowerCase(),`${p}1${BECH_ALPHABET.encode(u)}${bechChecksum(p,u,t)}`}function l(p,u=90){if(typeof p!="string")throw new Error(`bech32.decode input should be string, not ${typeof p}`);if(p.length<8||u!==!1&&p.length>u)throw new TypeError(`Wrong string length: ${p.length} (${p}). Expected (8..${u})`);const g=p.toLowerCase();if(p!==g&&p!==p.toUpperCase())throw new Error("String must be lowercase or uppercase");p=g;const E=p.lastIndexOf("1");if(E===0||E===-1)throw new Error('Letter "1" must be present between prefix and data only');const b=p.slice(0,E),h=p.slice(E+1);if(h.length<6)throw new Error("Data must be at least 6 characters long");const d=BECH_ALPHABET.decode(h).slice(0,-6),y=bechChecksum(b,d,t);if(!h.endsWith(y))throw new Error(`Invalid checksum in ${p}: expected "${y}"`);return{prefix:b,words:d}}const c=unsafeWrapper(l);function f(p){const{prefix:u,words:g}=l(p,!1);return{prefix:u,words:g,bytes:r(g)}}return{encode:a,decode:l,decodeToBytes:f,decodeUnsafe:c,fromWords:r,fromWordsUnsafe:s,toWords:o}}const bech32=genBech32("bech32");genBech32("bech32m");const utf8={encode:e=>new TextDecoder().decode(e),decode:e=>new TextEncoder().encode(e)},hex=chain(radix2(4),alphabet("0123456789abcdef"),join(""),normalize(e=>{if(typeof e!="string"||e.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`);return e.toLowerCase()})),CODERS={utf8,hex,base16,base32,base64,base64url,base58,base58xmr};`${Object.keys(CODERS).join(", ")}`;function number(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`positive integer expected, not ${e}`)}function bool(e){if(typeof e!="boolean")throw new Error(`boolean expected, not ${e}`)}function isBytes(e){return e instanceof Uint8Array||e!=null&&typeof e=="object"&&e.constructor.name==="Uint8Array"}function bytes(e,...t){if(!isBytes(e))throw new Error("Uint8Array expected");if(t.length>0&&!t.includes(e.length))throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`)}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */const u32=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4)),isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE)throw new Error("Non little-endian hardware is not supported");function checkOpts(e,t){if(t==null||typeof t!="object")throw new Error("options must be defined");return Object.assign(e,t)}function equalBytes(e,t){if(e.length!==t.length)return!1;let n=0;for(let r=0;r<e.length;r++)n|=e[r]^t[r];return n===0}const wrapCipher=(e,t)=>(Object.assign(t,e),t),BLOCK_SIZE=16,POLY=283;function mul2(e){return e<<1^POLY&-(e>>7)}function mul(e,t){let n=0;for(;t>0;t>>=1)n^=e&-(t&1),e=mul2(e);return n}const sbox=(()=>{let e=new Uint8Array(256);for(let n=0,r=1;n<256;n++,r^=mul2(r))e[n]=r;const t=new Uint8Array(256);t[0]=99;for(let n=0;n<255;n++){let r=e[255-n];r|=r<<8,t[e[n]]=(r^r>>4^r>>5^r>>6^r>>7^99)&255}return t})(),invSbox=sbox.map((e,t)=>sbox.indexOf(t)),rotr32_8=e=>e<<24|e>>>8,rotl32_8=e=>e<<8|e>>>24;function genTtable(e,t){if(e.length!==256)throw new Error("Wrong sbox length");const n=new Uint32Array(256).map((f,p)=>t(e[p])),r=n.map(rotl32_8),o=r.map(rotl32_8),s=o.map(rotl32_8),a=new Uint32Array(256*256),l=new Uint32Array(256*256),c=new Uint16Array(256*256);for(let f=0;f<256;f++)for(let p=0;p<256;p++){const u=f*256+p;a[u]=n[f]^r[p],l[u]=o[f]^s[p],c[u]=e[f]<<8|e[p]}return{sbox:e,sbox2:c,T0:n,T1:r,T2:o,T3:s,T01:a,T23:l}}const tableEncoding=genTtable(sbox,e=>mul(e,3)<<24|e<<16|e<<8|mul(e,2)),tableDecoding=genTtable(invSbox,e=>mul(e,11)<<24|mul(e,13)<<16|mul(e,9)<<8|mul(e,14)),xPowers=(()=>{const e=new Uint8Array(16);for(let t=0,n=1;t<16;t++,n=mul2(n))e[t]=n;return e})();function expandKeyLE(e){bytes(e);const t=e.length;if(![16,24,32].includes(t))throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${t}`);const{sbox2:n}=tableEncoding,r=u32(e),o=r.length,s=l=>applySbox(n,l,l,l,l),a=new Uint32Array(t+28);a.set(r);for(let l=o;l<a.length;l++){let c=a[l-1];l%o===0?c=s(rotr32_8(c))^xPowers[l/o-1]:o>6&&l%o===4&&(c=s(c)),a[l]=a[l-o]^c}return a}function expandKeyDecLE(e){const t=expandKeyLE(e),n=t.slice(),r=t.length,{sbox2:o}=tableEncoding,{T0:s,T1:a,T2:l,T3:c}=tableDecoding;for(let f=0;f<r;f+=4)for(let p=0;p<4;p++)n[f+p]=t[r-f-4+p];t.fill(0);for(let f=4;f<r-4;f++){const p=n[f],u=applySbox(o,p,p,p,p);n[f]=s[u&255]^a[u>>>8&255]^l[u>>>16&255]^c[u>>>24]}return n}function apply0123(e,t,n,r,o,s){return e[n<<8&65280|r>>>8&255]^t[o>>>8&65280|s>>>24&255]}function applySbox(e,t,n,r,o){return e[t&255|n&65280]|e[r>>>16&255|o>>>16&65280]<<16}function encrypt$1(e,t,n,r,o){const{sbox2:s,T01:a,T23:l}=tableEncoding;let c=0;t^=e[c++],n^=e[c++],r^=e[c++],o^=e[c++];const f=e.length/4-2;for(let b=0;b<f;b++){const h=e[c++]^apply0123(a,l,t,n,r,o),d=e[c++]^apply0123(a,l,n,r,o,t),y=e[c++]^apply0123(a,l,r,o,t,n),w=e[c++]^apply0123(a,l,o,t,n,r);t=h,n=d,r=y,o=w}const p=e[c++]^applySbox(s,t,n,r,o),u=e[c++]^applySbox(s,n,r,o,t),g=e[c++]^applySbox(s,r,o,t,n),E=e[c++]^applySbox(s,o,t,n,r);return{s0:p,s1:u,s2:g,s3:E}}function decrypt$1(e,t,n,r,o){const{sbox2:s,T01:a,T23:l}=tableDecoding;let c=0;t^=e[c++],n^=e[c++],r^=e[c++],o^=e[c++];const f=e.length/4-2;for(let b=0;b<f;b++){const h=e[c++]^apply0123(a,l,t,o,r,n),d=e[c++]^apply0123(a,l,n,t,o,r),y=e[c++]^apply0123(a,l,r,n,t,o),w=e[c++]^apply0123(a,l,o,r,n,t);t=h,n=d,r=y,o=w}const p=e[c++]^applySbox(s,t,o,r,n),u=e[c++]^applySbox(s,n,t,o,r),g=e[c++]^applySbox(s,r,n,t,o),E=e[c++]^applySbox(s,o,r,n,t);return{s0:p,s1:u,s2:g,s3:E}}function getDst(e,t){if(!t)return new Uint8Array(e);if(bytes(t),t.length<e)throw new Error(`aes: wrong destination length, expected at least ${e}, got: ${t.length}`);return t}function validateBlockDecrypt(e){if(bytes(e),e.length%BLOCK_SIZE!==0)throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE}`)}function validateBlockEncrypt(e,t,n){let r=e.length;const o=r%BLOCK_SIZE;if(!t&&o!==0)throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");const s=u32(e);if(t){let c=BLOCK_SIZE-o;c||(c=BLOCK_SIZE),r=r+c}const a=getDst(r,n),l=u32(a);return{b:s,o:l,out:a}}function validatePCKS(e,t){if(!t)return e;const n=e.length;if(!n)throw new Error("aes/pcks5: empty ciphertext not allowed");const r=e[n-1];if(r<=0||r>16)throw new Error(`aes/pcks5: wrong padding byte: ${r}`);const o=e.subarray(0,-r);for(let s=0;s<r;s++)if(e[n-s-1]!==r)throw new Error("aes/pcks5: wrong padding");return o}function padPCKS(e){const t=new Uint8Array(16),n=u32(t);t.set(e);const r=BLOCK_SIZE-e.length;for(let o=BLOCK_SIZE-r;o<BLOCK_SIZE;o++)t[o]=r;return n}const cbc=wrapCipher({blockSize:16,nonceLength:16},function(t,n,r={}){bytes(t),bytes(n,16);const o=!r.disablePadding;return{encrypt:(s,a)=>{const l=expandKeyLE(t),{b:c,o:f,out:p}=validateBlockEncrypt(s,o,a),u=u32(n);let g=u[0],E=u[1],b=u[2],h=u[3],d=0;for(;d+4<=c.length;)g^=c[d+0],E^=c[d+1],b^=c[d+2],h^=c[d+3],{s0:g,s1:E,s2:b,s3:h}=encrypt$1(l,g,E,b,h),f[d++]=g,f[d++]=E,f[d++]=b,f[d++]=h;if(o){const y=padPCKS(s.subarray(d*4));g^=y[0],E^=y[1],b^=y[2],h^=y[3],{s0:g,s1:E,s2:b,s3:h}=encrypt$1(l,g,E,b,h),f[d++]=g,f[d++]=E,f[d++]=b,f[d++]=h}return l.fill(0),p},decrypt:(s,a)=>{validateBlockDecrypt(s);const l=expandKeyDecLE(t),c=u32(n),f=getDst(s.length,a),p=u32(s),u=u32(f);let g=c[0],E=c[1],b=c[2],h=c[3];for(let d=0;d+4<=p.length;){const y=g,w=E,x=b,S=h;g=p[d+0],E=p[d+1],b=p[d+2],h=p[d+3];const{s0:k,s1:_,s2:$,s3:B}=decrypt$1(l,g,E,b,h);u[d++]=k^y,u[d++]=_^w,u[d++]=$^x,u[d++]=B^S}return l.fill(0),validatePCKS(f,o)}}}),_utf8ToBytes=e=>Uint8Array.from(e.split("").map(t=>t.charCodeAt(0))),sigma16=_utf8ToBytes("expand 16-byte k"),sigma32=_utf8ToBytes("expand 32-byte k"),sigma16_32=u32(sigma16),sigma32_32=u32(sigma32);sigma32_32.slice();function rotl(e,t){return e<<t|e>>>32-t}function isAligned32(e){return e.byteOffset%4===0}const BLOCK_LEN=64,BLOCK_LEN32=16,MAX_COUNTER=2**32-1,U32_EMPTY=new Uint32Array;function runCipher(e,t,n,r,o,s,a,l){const c=o.length,f=new Uint8Array(BLOCK_LEN),p=u32(f),u=isAligned32(o)&&isAligned32(s),g=u?u32(o):U32_EMPTY,E=u?u32(s):U32_EMPTY;for(let b=0;b<c;a++){if(e(t,n,r,p,a,l),a>=MAX_COUNTER)throw new Error("arx: counter overflow");const h=Math.min(BLOCK_LEN,c-b);if(u&&h===BLOCK_LEN){const d=b/4;if(b%4!==0)throw new Error("arx: invalid block position");for(let y=0,w;y<BLOCK_LEN32;y++)w=d+y,E[w]=g[w]^p[y];b+=BLOCK_LEN;continue}for(let d=0,y;d<h;d++)y=b+d,s[y]=o[y]^f[d];b+=h}}function createCipher(e,t){const{allowShortKeys:n,extendNonceFn:r,counterLength:o,counterRight:s,rounds:a}=checkOpts({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},t);if(typeof e!="function")throw new Error("core must be a function");return number(o),number(a),bool(s),bool(n),(l,c,f,p,u=0)=>{bytes(l),bytes(c),bytes(f);const g=f.length;if(p||(p=new Uint8Array(g)),bytes(p),number(u),u<0||u>=MAX_COUNTER)throw new Error("arx: counter overflow");if(p.length<g)throw new Error(`arx: output (${p.length}) is shorter than data (${g})`);const E=[];let b=l.length,h,d;if(b===32)h=l.slice(),E.push(h),d=sigma32_32;else if(b===16&&n)h=new Uint8Array(32),h.set(l),h.set(l,16),d=sigma16_32,E.push(h);else throw new Error(`arx: invalid 32-byte key, got length=${b}`);isAligned32(c)||(c=c.slice(),E.push(c));const y=u32(h);if(r){if(c.length!==24)throw new Error("arx: extended nonce must be 24 bytes");r(d,y,u32(c.subarray(0,16)),y),c=c.subarray(16)}const w=16-o;if(w!==c.length)throw new Error(`arx: nonce must be ${w} or 16 bytes`);if(w!==12){const S=new Uint8Array(12);S.set(c,s?0:12-c.length),c=S,E.push(c)}const x=u32(c);for(runCipher(e,d,y,x,f,p,u,a);E.length>0;)E.pop().fill(0);return p}}function chachaCore(e,t,n,r,o,s=20){let a=e[0],l=e[1],c=e[2],f=e[3],p=t[0],u=t[1],g=t[2],E=t[3],b=t[4],h=t[5],d=t[6],y=t[7],w=o,x=n[0],S=n[1],k=n[2],_=a,$=l,B=c,I=f,L=p,T=u,U=g,O=E,M=b,m=h,v=d,A=y,R=w,C=x,H=S,P=k;for(let D=0;D<s;D+=2)_=_+L|0,R=rotl(R^_,16),M=M+R|0,L=rotl(L^M,12),_=_+L|0,R=rotl(R^_,8),M=M+R|0,L=rotl(L^M,7),$=$+T|0,C=rotl(C^$,16),m=m+C|0,T=rotl(T^m,12),$=$+T|0,C=rotl(C^$,8),m=m+C|0,T=rotl(T^m,7),B=B+U|0,H=rotl(H^B,16),v=v+H|0,U=rotl(U^v,12),B=B+U|0,H=rotl(H^B,8),v=v+H|0,U=rotl(U^v,7),I=I+O|0,P=rotl(P^I,16),A=A+P|0,O=rotl(O^A,12),I=I+O|0,P=rotl(P^I,8),A=A+P|0,O=rotl(O^A,7),_=_+T|0,P=rotl(P^_,16),v=v+P|0,T=rotl(T^v,12),_=_+T|0,P=rotl(P^_,8),v=v+P|0,T=rotl(T^v,7),$=$+U|0,R=rotl(R^$,16),A=A+R|0,U=rotl(U^A,12),$=$+U|0,R=rotl(R^$,8),A=A+R|0,U=rotl(U^A,7),B=B+O|0,C=rotl(C^B,16),M=M+C|0,O=rotl(O^M,12),B=B+O|0,C=rotl(C^B,8),M=M+C|0,O=rotl(O^M,7),I=I+L|0,H=rotl(H^I,16),m=m+H|0,L=rotl(L^m,12),I=I+L|0,H=rotl(H^I,8),m=m+H|0,L=rotl(L^m,7);let N=0;r[N++]=a+_|0,r[N++]=l+$|0,r[N++]=c+B|0,r[N++]=f+I|0,r[N++]=p+L|0,r[N++]=u+T|0,r[N++]=g+U|0,r[N++]=E+O|0,r[N++]=b+M|0,r[N++]=h+m|0,r[N++]=d+v|0,r[N++]=y+A|0,r[N++]=w+R|0,r[N++]=x+C|0,r[N++]=S+H|0,r[N++]=k+P|0}const chacha20=createCipher(chachaCore,{counterRight:!1,counterLength:4,allowShortKeys:!1});class HMAC extends Hash{constructor(t,n){super(),this.finished=!1,this.destroyed=!1,assert.hash(t);const r=toBytes(n);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?t.create().update(r).digest():r);for(let a=0;a<s.length;a++)s[a]^=54;this.iHash.update(s),this.oHash=t.create();for(let a=0;a<s.length;a++)s[a]^=106;this.oHash.update(s),s.fill(0)}update(t){return assert.exists(this),this.iHash.update(t),this}digestInto(t){assert.exists(this),assert.bytes(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:o,destroyed:s,blockLen:a,outputLen:l}=this;return t=t,t.finished=o,t.destroyed=s,t.blockLen=a,t.outputLen=l,t.oHash=n._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const hmac=(e,t,n)=>new HMAC(e,t).update(n).digest();hmac.create=(e,t)=>new HMAC(e,t);function extract(e,t,n){return assert.hash(e),hmac(e,toBytes(n),toBytes(t))}const HKDF_COUNTER=new Uint8Array([0]),EMPTY_BUFFER=new Uint8Array;function expand(e,t,n,r=32){if(assert.hash(e),assert.number(r),r>255*e.outputLen)throw new Error("Length should be <= 255*HashLen");const o=Math.ceil(r/e.outputLen);n===void 0&&(n=EMPTY_BUFFER);const s=new Uint8Array(o*e.outputLen),a=hmac.create(e,t),l=a._cloneInto(),c=new Uint8Array(a.outputLen);for(let f=0;f<o;f++)HKDF_COUNTER[0]=f+1,l.update(f===0?EMPTY_BUFFER:c).update(n).update(HKDF_COUNTER).digestInto(c),s.set(c,e.outputLen*f),a._cloneInto(l);return a.destroy(),l.destroy(),c.fill(0),HKDF_COUNTER.fill(0),s.slice(0,r)}var __defProp=Object.defineProperty,__export=(e,t)=>{for(var n in t)__defProp(e,n,{get:t[n],enumerable:!0})},verifiedSymbol=Symbol("verified"),isRecord=e=>e instanceof Object;function validateEvent(e){if(!isRecord(e)||typeof e.kind!="number"||typeof e.content!="string"||typeof e.created_at!="number"||typeof e.pubkey!="string"||!e.pubkey.match(/^[a-f0-9]{64}$/)||!Array.isArray(e.tags))return!1;for(let t=0;t<e.tags.length;t++){let n=e.tags[t];if(!Array.isArray(n))return!1;for(let r=0;r<n.length;r++)if(typeof n[r]!="string")return!1}return!0}var utils_exports={};__export(utils_exports,{Queue:()=>Queue,QueueNode:()=>QueueNode,binarySearch:()=>binarySearch,bytesToHex:()=>bytesToHex,hexToBytes:()=>hexToBytes,insertEventIntoAscendingList:()=>insertEventIntoAscendingList,insertEventIntoDescendingList:()=>insertEventIntoDescendingList,normalizeURL:()=>normalizeURL,utf8Decoder:()=>utf8Decoder,utf8Encoder:()=>utf8Encoder});var utf8Decoder=new TextDecoder("utf-8"),utf8Encoder=new TextEncoder;function normalizeURL(e){try{e.indexOf("://")===-1&&(e="wss://"+e);let t=new URL(e);return t.pathname=t.pathname.replace(/\/+/g,"/"),t.pathname.endsWith("/")&&(t.pathname=t.pathname.slice(0,-1)),(t.port==="80"&&t.protocol==="ws:"||t.port==="443"&&t.protocol==="wss:")&&(t.port=""),t.searchParams.sort(),t.hash="",t.toString()}catch{throw new Error(`Invalid URL: ${e}`)}}function insertEventIntoDescendingList(e,t){const[n,r]=binarySearch(e,o=>t.id===o.id?0:t.created_at===o.created_at?-1:o.created_at-t.created_at);return r||e.splice(n,0,t),e}function insertEventIntoAscendingList(e,t){const[n,r]=binarySearch(e,o=>t.id===o.id?0:t.created_at===o.created_at?-1:t.created_at-o.created_at);return r||e.splice(n,0,t),e}function binarySearch(e,t){let n=0,r=e.length-1;for(;n<=r;){const o=Math.floor((n+r)/2),s=t(e[o]);if(s===0)return[o,!0];s<0?r=o-1:n=o+1}return[n,!1]}var QueueNode=class{constructor(e){W(this,"value");W(this,"next",null);W(this,"prev",null);this.value=e}},Queue=class{constructor(){W(this,"first");W(this,"last");this.first=null,this.last=null}enqueue(e){const t=new QueueNode(e);return this.last?this.last===this.first?(this.last=t,this.last.prev=this.first,this.first.next=t):(t.prev=this.last,this.last.next=t,this.last=t):(this.first=t,this.last=t),!0}dequeue(){if(!this.first)return null;if(this.first===this.last){const t=this.first;return this.first=null,this.last=null,t.value}const e=this.first;return this.first=e.next,this.first&&(this.first.prev=null),e.value}},JS=class{generateSecretKey(){return schnorr.utils.randomPrivateKey()}getPublicKey(e){return bytesToHex(schnorr.getPublicKey(e))}finalizeEvent(e,t){const n=e;return n.pubkey=bytesToHex(schnorr.getPublicKey(t)),n.id=getEventHash(n),n.sig=bytesToHex(schnorr.sign(getEventHash(n),t)),n[verifiedSymbol]=!0,n}verifyEvent(e){if(typeof e[verifiedSymbol]=="boolean")return e[verifiedSymbol];const t=getEventHash(e);if(t!==e.id)return e[verifiedSymbol]=!1,!1;try{const n=schnorr.verify(e.sig,t,e.pubkey);return e[verifiedSymbol]=n,n}catch{return e[verifiedSymbol]=!1,!1}}};function serializeEvent(e){if(!validateEvent(e))throw new Error("can't serialize event with wrong or missing properties");return JSON.stringify([0,e.pubkey,e.created_at,e.kind,e.tags,e.content])}function getEventHash(e){let t=sha256(utf8Encoder.encode(serializeEvent(e)));return bytesToHex(t)}var i=new JS,generateSecretKey=i.generateSecretKey,getPublicKey=i.getPublicKey,finalizeEvent=i.finalizeEvent,verifyEvent=i.verifyEvent,kinds_exports={};__export(kinds_exports,{Application:()=>Application,BadgeAward:()=>BadgeAward,BadgeDefinition:()=>BadgeDefinition,BlockedRelaysList:()=>BlockedRelaysList,BookmarkList:()=>BookmarkList,Bookmarksets:()=>Bookmarksets,Calendar:()=>Calendar,CalendarEventRSVP:()=>CalendarEventRSVP,ChannelCreation:()=>ChannelCreation,ChannelHideMessage:()=>ChannelHideMessage,ChannelMessage:()=>ChannelMessage,ChannelMetadata:()=>ChannelMetadata,ChannelMuteUser:()=>ChannelMuteUser,ClassifiedListing:()=>ClassifiedListing,ClientAuth:()=>ClientAuth,CommunitiesList:()=>CommunitiesList,CommunityDefinition:()=>CommunityDefinition,CommunityPostApproval:()=>CommunityPostApproval,Contacts:()=>Contacts,CreateOrUpdateProduct:()=>CreateOrUpdateProduct,CreateOrUpdateStall:()=>CreateOrUpdateStall,Curationsets:()=>Curationsets,Date:()=>Date2,DirectMessageRelaysList:()=>DirectMessageRelaysList,DraftClassifiedListing:()=>DraftClassifiedListing,DraftLong:()=>DraftLong,Emojisets:()=>Emojisets,EncryptedDirectMessage:()=>EncryptedDirectMessage,EventDeletion:()=>EventDeletion,FileMetadata:()=>FileMetadata,FileServerPreference:()=>FileServerPreference,Followsets:()=>Followsets,GenericRepost:()=>GenericRepost,Genericlists:()=>Genericlists,GiftWrap:()=>GiftWrap,HTTPAuth:()=>HTTPAuth,Handlerinformation:()=>Handlerinformation,Handlerrecommendation:()=>Handlerrecommendation,Highlights:()=>Highlights,InterestsList:()=>InterestsList,Interestsets:()=>Interestsets,JobFeedback:()=>JobFeedback,JobRequest:()=>JobRequest,JobResult:()=>JobResult,Label:()=>Label,LightningPubRPC:()=>LightningPubRPC,LiveChatMessage:()=>LiveChatMessage,LiveEvent:()=>LiveEvent,LongFormArticle:()=>LongFormArticle,Metadata:()=>Metadata,Mutelist:()=>Mutelist,NWCWalletInfo:()=>NWCWalletInfo,NWCWalletRequest:()=>NWCWalletRequest,NWCWalletResponse:()=>NWCWalletResponse,NostrConnect:()=>NostrConnect,OpenTimestamps:()=>OpenTimestamps,Pinlist:()=>Pinlist,PrivateDirectMessage:()=>PrivateDirectMessage,ProblemTracker:()=>ProblemTracker,ProfileBadges:()=>ProfileBadges,PublicChatsList:()=>PublicChatsList,Reaction:()=>Reaction,RecommendRelay:()=>RecommendRelay,RelayList:()=>RelayList,Relaysets:()=>Relaysets,Report:()=>Report,Reporting:()=>Reporting,Repost:()=>Repost,Seal:()=>Seal,SearchRelaysList:()=>SearchRelaysList,ShortTextNote:()=>ShortTextNote,Time:()=>Time,UserEmojiList:()=>UserEmojiList,UserStatuses:()=>UserStatuses,Zap:()=>Zap,ZapGoal:()=>ZapGoal,ZapRequest:()=>ZapRequest,classifyKind:()=>classifyKind,isAddressableKind:()=>isAddressableKind,isEphemeralKind:()=>isEphemeralKind,isKind:()=>isKind,isRegularKind:()=>isRegularKind,isReplaceableKind:()=>isReplaceableKind});function isRegularKind(e){return 1e3<=e&&e<1e4||[1,2,4,5,6,7,8,16,40,41,42,43,44].includes(e)}function isReplaceableKind(e){return[0,3].includes(e)||1e4<=e&&e<2e4}function isEphemeralKind(e){return 2e4<=e&&e<3e4}function isAddressableKind(e){return 3e4<=e&&e<4e4}function classifyKind(e){return isRegularKind(e)?"regular":isReplaceableKind(e)?"replaceable":isEphemeralKind(e)?"ephemeral":isAddressableKind(e)?"parameterized":"unknown"}function isKind(e,t){const n=t instanceof Array?t:[t];return validateEvent(e)&&n.includes(e.kind)||!1}var Metadata=0,ShortTextNote=1,RecommendRelay=2,Contacts=3,EncryptedDirectMessage=4,EventDeletion=5,Repost=6,Reaction=7,BadgeAward=8,Seal=13,PrivateDirectMessage=14,GenericRepost=16,ChannelCreation=40,ChannelMetadata=41,ChannelMessage=42,ChannelHideMessage=43,ChannelMuteUser=44,OpenTimestamps=1040,GiftWrap=1059,FileMetadata=1063,LiveChatMessage=1311,ProblemTracker=1971,Report=1984,Reporting=1984,Label=1985,CommunityPostApproval=4550,JobRequest=5999,JobResult=6999,JobFeedback=7e3,ZapGoal=9041,ZapRequest=9734,Zap=9735,Highlights=9802,Mutelist=1e4,Pinlist=10001,RelayList=10002,BookmarkList=10003,CommunitiesList=10004,PublicChatsList=10005,BlockedRelaysList=10006,SearchRelaysList=10007,InterestsList=10015,UserEmojiList=10030,DirectMessageRelaysList=10050,FileServerPreference=10096,NWCWalletInfo=13194,LightningPubRPC=21e3,ClientAuth=22242,NWCWalletRequest=23194,NWCWalletResponse=23195,NostrConnect=24133,HTTPAuth=27235,Followsets=3e4,Genericlists=30001,Relaysets=30002,Bookmarksets=30003,Curationsets=30004,ProfileBadges=30008,BadgeDefinition=30009,Interestsets=30015,CreateOrUpdateStall=30017,CreateOrUpdateProduct=30018,LongFormArticle=30023,DraftLong=30024,Emojisets=30030,Application=30078,LiveEvent=30311,UserStatuses=30315,ClassifiedListing=30402,DraftClassifiedListing=30403,Date2=31922,Time=31923,Calendar=31924,CalendarEventRSVP=31925,Handlerrecommendation=31989,Handlerinformation=31990,CommunityDefinition=34550,fakejson_exports={};__export(fakejson_exports,{getHex64:()=>getHex64,getInt:()=>getInt,getSubscriptionId:()=>getSubscriptionId,matchEventId:()=>matchEventId,matchEventKind:()=>matchEventKind,matchEventPubkey:()=>matchEventPubkey});function getHex64(e,t){let n=t.length+3,r=e.indexOf(`"${t}":`)+n,o=e.slice(r).indexOf('"')+r+1;return e.slice(o,o+64)}function getInt(e,t){let n=t.length,r=e.indexOf(`"${t}":`)+n+3,o=e.slice(r),s=Math.min(o.indexOf(","),o.indexOf("}"));return parseInt(o.slice(0,s),10)}function getSubscriptionId(e){let t=e.slice(0,22).indexOf('"EVENT"');if(t===-1)return null;let n=e.slice(t+7+1).indexOf('"');if(n===-1)return null;let r=t+7+1+n,o=e.slice(r+1,80).indexOf('"');if(o===-1)return null;let s=r+1+o;return e.slice(r+1,s)}function matchEventId(e,t){return t===getHex64(e,"id")}function matchEventPubkey(e,t){return t===getHex64(e,"pubkey")}function matchEventKind(e,t){return t===getInt(e,"kind")}var nip42_exports={};__export(nip42_exports,{makeAuthEvent:()=>makeAuthEvent});function makeAuthEvent(e,t){return{kind:ClientAuth,created_at:Math.floor(Date.now()/1e3),tags:[["relay",e],["challenge",t]],content:""}}var _WebSocket;try{_WebSocket=WebSocket}catch{}var _WebSocket2;try{_WebSocket2=WebSocket}catch{}var nip19_exports={};__export(nip19_exports,{BECH32_REGEX:()=>BECH32_REGEX,Bech32MaxSize:()=>Bech32MaxSize,NostrTypeGuard:()=>NostrTypeGuard,decode:()=>decode,decodeNostrURI:()=>decodeNostrURI,encodeBytes:()=>encodeBytes,naddrEncode:()=>naddrEncode,neventEncode:()=>neventEncode,noteEncode:()=>noteEncode,nprofileEncode:()=>nprofileEncode,npubEncode:()=>npubEncode,nsecEncode:()=>nsecEncode});var NostrTypeGuard={isNProfile:e=>/^nprofile1[a-z\d]+$/.test(e||""),isNEvent:e=>/^nevent1[a-z\d]+$/.test(e||""),isNAddr:e=>/^naddr1[a-z\d]+$/.test(e||""),isNSec:e=>/^nsec1[a-z\d]{58}$/.test(e||""),isNPub:e=>/^npub1[a-z\d]{58}$/.test(e||""),isNote:e=>/^note1[a-z\d]+$/.test(e||""),isNcryptsec:e=>/^ncryptsec1[a-z\d]+$/.test(e||"")},Bech32MaxSize=5e3,BECH32_REGEX=/[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;function integerToUint8Array(e){const t=new Uint8Array(4);return t[0]=e>>24&255,t[1]=e>>16&255,t[2]=e>>8&255,t[3]=e&255,t}function decodeNostrURI(e){try{return e.startsWith("nostr:")&&(e=e.substring(6)),decode(e)}catch{return{type:"invalid",data:null}}}function decode(e){var o,s,a,l,c,f,p;let{prefix:t,words:n}=bech32.decode(e,Bech32MaxSize),r=new Uint8Array(bech32.fromWords(n));switch(t){case"nprofile":{let u=parseTLV(r);if(!((o=u[0])!=null&&o[0]))throw new Error("missing TLV 0 for nprofile");if(u[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");return{type:"nprofile",data:{pubkey:bytesToHex(u[0][0]),relays:u[1]?u[1].map(g=>utf8Decoder.decode(g)):[]}}}case"nevent":{let u=parseTLV(r);if(!((s=u[0])!=null&&s[0]))throw new Error("missing TLV 0 for nevent");if(u[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");if(u[2]&&u[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(u[3]&&u[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"nevent",data:{id:bytesToHex(u[0][0]),relays:u[1]?u[1].map(g=>utf8Decoder.decode(g)):[],author:(a=u[2])!=null&&a[0]?bytesToHex(u[2][0]):void 0,kind:(l=u[3])!=null&&l[0]?parseInt(bytesToHex(u[3][0]),16):void 0}}}case"naddr":{let u=parseTLV(r);if(!((c=u[0])!=null&&c[0]))throw new Error("missing TLV 0 for naddr");if(!((f=u[2])!=null&&f[0]))throw new Error("missing TLV 2 for naddr");if(u[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(!((p=u[3])!=null&&p[0]))throw new Error("missing TLV 3 for naddr");if(u[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"naddr",data:{identifier:utf8Decoder.decode(u[0][0]),pubkey:bytesToHex(u[2][0]),kind:parseInt(bytesToHex(u[3][0]),16),relays:u[1]?u[1].map(g=>utf8Decoder.decode(g)):[]}}}case"nsec":return{type:t,data:r};case"npub":case"note":return{type:t,data:bytesToHex(r)};default:throw new Error(`unknown prefix ${t}`)}}function parseTLV(e){let t={},n=e;for(;n.length>0;){let r=n[0],o=n[1],s=n.slice(2,2+o);if(n=n.slice(2+o),s.length<o)throw new Error(`not enough data to read on TLV ${r}`);t[r]=t[r]||[],t[r].push(s)}return t}function nsecEncode(e){return encodeBytes("nsec",e)}function npubEncode(e){return encodeBytes("npub",hexToBytes(e))}function noteEncode(e){return encodeBytes("note",hexToBytes(e))}function encodeBech32(e,t){let n=bech32.toWords(t);return bech32.encode(e,n,Bech32MaxSize)}function encodeBytes(e,t){return encodeBech32(e,t)}function nprofileEncode(e){let t=encodeTLV({0:[hexToBytes(e.pubkey)],1:(e.relays||[]).map(n=>utf8Encoder.encode(n))});return encodeBech32("nprofile",t)}function neventEncode(e){let t;e.kind!==void 0&&(t=integerToUint8Array(e.kind));let n=encodeTLV({0:[hexToBytes(e.id)],1:(e.relays||[]).map(r=>utf8Encoder.encode(r)),2:e.author?[hexToBytes(e.author)]:[],3:t?[new Uint8Array(t)]:[]});return encodeBech32("nevent",n)}function naddrEncode(e){let t=new ArrayBuffer(4);new DataView(t).setUint32(0,e.kind,!1);let n=encodeTLV({0:[utf8Encoder.encode(e.identifier)],1:(e.relays||[]).map(r=>utf8Encoder.encode(r)),2:[hexToBytes(e.pubkey)],3:[new Uint8Array(t)]});return encodeBech32("naddr",n)}function encodeTLV(e){let t=[];return Object.entries(e).reverse().forEach(([n,r])=>{r.forEach(o=>{let s=new Uint8Array(o.length+2);s.set([parseInt(n)],0),s.set([o.length],1),s.set(o,2),t.push(s)})}),concatBytes(...t)}var nip04_exports={};__export(nip04_exports,{decrypt:()=>decrypt,encrypt:()=>encrypt});function encrypt(e,t,n){const r=e instanceof Uint8Array?bytesToHex(e):e,o=secp256k1.getSharedSecret(r,"02"+t),s=getNormalizedX(o);let a=Uint8Array.from(randomBytes(16)),l=utf8Encoder.encode(n),c=cbc(s,a).encrypt(l),f=base64.encode(new Uint8Array(c)),p=base64.encode(new Uint8Array(a.buffer));return`${f}?iv=${p}`}function decrypt(e,t,n){const r=e instanceof Uint8Array?bytesToHex(e):e;let[o,s]=n.split("?iv="),a=secp256k1.getSharedSecret(r,"02"+t),l=getNormalizedX(a),c=base64.decode(s),f=base64.decode(o),p=cbc(l,c).decrypt(f);return utf8Decoder.decode(p)}function getNormalizedX(e){return e.slice(1,33)}var nip05_exports={};__export(nip05_exports,{NIP05_REGEX:()=>NIP05_REGEX,isNip05:()=>isNip05,isValid:()=>isValid,queryProfile:()=>queryProfile,searchDomain:()=>searchDomain,useFetchImplementation:()=>useFetchImplementation});var NIP05_REGEX=/^(?:([\w.+-]+)@)?([\w_-]+(\.[\w_-]+)+)$/,isNip05=e=>NIP05_REGEX.test(e||""),_fetch;try{_fetch=fetch}catch{}function useFetchImplementation(e){_fetch=e}async function searchDomain(e,t=""){try{const n=`https://${e}/.well-known/nostr.json?name=${t}`,r=await _fetch(n,{redirect:"manual"});if(r.status!==200)throw Error("Wrong response code");return(await r.json()).names}catch{return{}}}async function queryProfile(e){var o;const t=e.match(NIP05_REGEX);if(!t)return null;const[,n="_",r]=t;try{const s=`https://${r}/.well-known/nostr.json?name=${n}`,a=await _fetch(s,{redirect:"manual"});if(a.status!==200)throw Error("Wrong response code");const l=await a.json(),c=l.names[n];return c?{pubkey:c,relays:(o=l.relays)==null?void 0:o[c]}:null}catch{return null}}async function isValid(e,t){const n=await queryProfile(t);return n?n.pubkey===e:!1}var nip10_exports={};__export(nip10_exports,{parse:()=>parse});function parse(e){const t={reply:void 0,root:void 0,mentions:[],profiles:[],quotes:[]};let n,r;for(let o=e.tags.length-1;o>=0;o--){const s=e.tags[o];if(s[0]==="e"&&s[1]){const[a,l,c,f,p]=s,u={id:l,relays:c?[c]:[],author:p};if(f==="root"){t.root=u;continue}if(f==="reply"){t.reply=u;continue}if(f==="mention"){t.mentions.push(u);continue}n?r=u:n=u,t.mentions.push(u);continue}if(s[0]==="q"&&s[1]){const[a,l,c]=s;t.quotes.push({id:l,relays:c?[c]:[]})}if(s[0]==="p"&&s[1]){t.profiles.push({pubkey:s[1],relays:s[2]?[s[2]]:[]});continue}}return t.root||(t.root=r||n||t.reply),t.reply||(t.reply=n||t.root),[t.reply,t.root].forEach(o=>{if(!o)return;let s=t.mentions.indexOf(o);if(s!==-1&&t.mentions.splice(s,1),o.author){let a=t.profiles.find(l=>l.pubkey===o.author);a&&a.relays&&(o.relays||(o.relays=[]),a.relays.forEach(l=>{var c;((c=o.relays)==null?void 0:c.indexOf(l))===-1&&o.relays.push(l)}),a.relays=o.relays)}}),t.mentions.forEach(o=>{if(o.author){let s=t.profiles.find(a=>a.pubkey===o.author);s&&s.relays&&(o.relays||(o.relays=[]),s.relays.forEach(a=>{o.relays.indexOf(a)===-1&&o.relays.push(a)}),s.relays=o.relays)}}),t}var nip11_exports={};__export(nip11_exports,{fetchRelayInformation:()=>fetchRelayInformation,useFetchImplementation:()=>useFetchImplementation2});var _fetch2;try{_fetch2=fetch}catch{}function useFetchImplementation2(e){_fetch2=e}async function fetchRelayInformation(e){return await(await fetch(e.replace("ws://","http://").replace("wss://","https://"),{headers:{Accept:"application/nostr+json"}})).json()}var nip13_exports={};__export(nip13_exports,{fastEventHash:()=>fastEventHash,getPow:()=>getPow,minePow:()=>minePow});function getPow(e){let t=0;for(let n=0;n<64;n+=8){const r=parseInt(e.substring(n,n+8),16);if(r===0)t+=32;else{t+=Math.clz32(r);break}}return t}function minePow(e,t){let n=0;const r=e,o=["nonce",n.toString(),t.toString()];for(r.tags.push(o);;){const s=Math.floor(new Date().getTime()/1e3);if(s!==r.created_at&&(n=0,r.created_at=s),o[1]=(++n).toString(),r.id=fastEventHash(r),getPow(r.id)>=t)break}return r}function fastEventHash(e){return bytesToHex(sha256(utf8Encoder.encode(JSON.stringify([0,e.pubkey,e.created_at,e.kind,e.tags,e.content]))))}var nip17_exports={};__export(nip17_exports,{unwrapEvent:()=>unwrapEvent2,unwrapManyEvents:()=>unwrapManyEvents2,wrapEvent:()=>wrapEvent2,wrapManyEvents:()=>wrapManyEvents2});var nip59_exports={};__export(nip59_exports,{createRumor:()=>createRumor,createSeal:()=>createSeal,createWrap:()=>createWrap,unwrapEvent:()=>unwrapEvent,unwrapManyEvents:()=>unwrapManyEvents,wrapEvent:()=>wrapEvent,wrapManyEvents:()=>wrapManyEvents});var nip44_exports={};__export(nip44_exports,{decrypt:()=>decrypt2,encrypt:()=>encrypt2,getConversationKey:()=>getConversationKey,v2:()=>v2});var minPlaintextSize=1,maxPlaintextSize=65535;function getConversationKey(e,t){const n=secp256k1.getSharedSecret(e,"02"+t).subarray(1,33);return extract(sha256,n,"nip44-v2")}function getMessageKeys(e,t){const n=expand(sha256,e,t,76);return{chacha_key:n.subarray(0,32),chacha_nonce:n.subarray(32,44),hmac_key:n.subarray(44,76)}}function calcPaddedLen(e){if(!Number.isSafeInteger(e)||e<1)throw new Error("expected positive integer");if(e<=32)return 32;const t=1<<Math.floor(Math.log2(e-1))+1,n=t<=256?32:t/8;return n*(Math.floor((e-1)/n)+1)}function writeU16BE(e){if(!Number.isSafeInteger(e)||e<minPlaintextSize||e>maxPlaintextSize)throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");const t=new Uint8Array(2);return new DataView(t.buffer).setUint16(0,e,!1),t}function pad(e){const t=utf8Encoder.encode(e),n=t.length,r=writeU16BE(n),o=new Uint8Array(calcPaddedLen(n)-n);return concatBytes(r,t,o)}function unpad(e){const t=new DataView(e.buffer).getUint16(0),n=e.subarray(2,2+t);if(t<minPlaintextSize||t>maxPlaintextSize||n.length!==t||e.length!==2+calcPaddedLen(t))throw new Error("invalid padding");return utf8Decoder.decode(n)}function hmacAad(e,t,n){if(n.length!==32)throw new Error("AAD associated data must be 32 bytes");const r=concatBytes(n,t);return hmac(sha256,e,r)}function decodePayload(e){if(typeof e!="string")throw new Error("payload must be a valid string");const t=e.length;if(t<132||t>87472)throw new Error("invalid payload length: "+t);if(e[0]==="#")throw new Error("unknown encryption version");let n;try{n=base64.decode(e)}catch(s){throw new Error("invalid base64: "+s.message)}const r=n.length;if(r<99||r>65603)throw new Error("invalid data length: "+r);const o=n[0];if(o!==2)throw new Error("unknown encryption version "+o);return{nonce:n.subarray(1,33),ciphertext:n.subarray(33,-32),mac:n.subarray(-32)}}function encrypt2(e,t,n=randomBytes(32)){const{chacha_key:r,chacha_nonce:o,hmac_key:s}=getMessageKeys(t,n),a=pad(e),l=chacha20(r,o,a),c=hmacAad(s,l,n);return base64.encode(concatBytes(new Uint8Array([2]),n,l,c))}function decrypt2(e,t){const{nonce:n,ciphertext:r,mac:o}=decodePayload(e),{chacha_key:s,chacha_nonce:a,hmac_key:l}=getMessageKeys(t,n),c=hmacAad(l,r,n);if(!equalBytes(c,o))throw new Error("invalid MAC");const f=chacha20(s,a,r);return unpad(f)}var v2={utils:{getConversationKey,calcPaddedLen},encrypt:encrypt2,decrypt:decrypt2},TWO_DAYS=2*24*60*60,now=()=>Math.round(Date.now()/1e3),randomNow=()=>Math.round(now()-Math.random()*TWO_DAYS),nip44ConversationKey=(e,t)=>getConversationKey(e,t),nip44Encrypt=(e,t,n)=>encrypt2(JSON.stringify(e),nip44ConversationKey(t,n)),nip44Decrypt=(e,t)=>JSON.parse(decrypt2(e.content,nip44ConversationKey(t,e.pubkey)));function createRumor(e,t){const n={created_at:now(),content:"",tags:[],...e,pubkey:getPublicKey(t)};return n.id=getEventHash(n),n}function createSeal(e,t,n){return finalizeEvent({kind:Seal,content:nip44Encrypt(e,t,n),created_at:randomNow(),tags:[]},t)}function createWrap(e,t){const n=generateSecretKey();return finalizeEvent({kind:GiftWrap,content:nip44Encrypt(e,n,t),created_at:randomNow(),tags:[["p",t]]},n)}function wrapEvent(e,t,n){const r=createRumor(e,t),o=createSeal(r,t,n);return createWrap(o,n)}function wrapManyEvents(e,t,n){if(!n||n.length===0)throw new Error("At least one recipient is required.");const r=getPublicKey(t),o=[wrapEvent(e,t,r)];return n.forEach(s=>{o.push(wrapEvent(e,t,s))}),o}function unwrapEvent(e,t){const n=nip44Decrypt(e,t);return nip44Decrypt(n,t)}function unwrapManyEvents(e,t){let n=[];return e.forEach(r=>{n.push(unwrapEvent(r,t))}),n.sort((r,o)=>r.created_at-o.created_at),n}function createEvent(e,t,n,r){const o={created_at:Math.ceil(Date.now()/1e3),kind:PrivateDirectMessage,tags:[],content:t};return(Array.isArray(e)?e:[e]).forEach(({publicKey:a,relayUrl:l})=>{o.tags.push(l?["p",a,l]:["p",a])}),r&&o.tags.push(["e",r.eventId,r.relayUrl||"","reply"]),n&&o.tags.push(["subject",n]),o}function wrapEvent2(e,t,n,r,o){const s=createEvent(t,n,r,o);return wrapEvent(s,e,t.publicKey)}function wrapManyEvents2(e,t,n,r,o){if(!t||t.length===0)throw new Error("At least one recipient is required.");return[{publicKey:getPublicKey(e)},...t].map(a=>wrapEvent2(e,a,n,r,o))}var unwrapEvent2=unwrapEvent,unwrapManyEvents2=unwrapManyEvents,nip18_exports={};__export(nip18_exports,{finishRepostEvent:()=>finishRepostEvent,getRepostedEvent:()=>getRepostedEvent,getRepostedEventPointer:()=>getRepostedEventPointer});function finishRepostEvent(e,t,n,r){var a;let o;const s=[...e.tags??[],["e",t.id,n],["p",t.pubkey]];return t.kind===ShortTextNote?o=Repost:(o=GenericRepost,s.push(["k",String(t.kind)])),finalizeEvent({kind:o,tags:s,content:e.content===""||(a=t.tags)!=null&&a.find(l=>l[0]==="-")?"":JSON.stringify(t),created_at:e.created_at},r)}function getRepostedEventPointer(e){if(![Repost,GenericRepost].includes(e.kind))return;let t,n;for(let r=e.tags.length-1;r>=0&&(t===void 0||n===void 0);r--){const o=e.tags[r];o.length>=2&&(o[0]==="e"&&t===void 0?t=o:o[0]==="p"&&n===void 0&&(n=o))}if(t!==void 0)return{id:t[1],relays:[t[2],n==null?void 0:n[2]].filter(r=>typeof r=="string"),author:n==null?void 0:n[1]}}function getRepostedEvent(e,{skipVerification:t}={}){const n=getRepostedEventPointer(e);if(n===void 0||e.content==="")return;let r;try{r=JSON.parse(e.content)}catch{return}if(r.id===n.id&&!(!t&&!verifyEvent(r)))return r}var nip21_exports={};__export(nip21_exports,{NOSTR_URI_REGEX:()=>NOSTR_URI_REGEX,parse:()=>parse2,test:()=>test});var NOSTR_URI_REGEX=new RegExp(`nostr:(${BECH32_REGEX.source})`);function test(e){return typeof e=="string"&&new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(e)}function parse2(e){const t=e.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));if(!t)throw new Error(`Invalid Nostr URI: ${e}`);return{uri:t[0],value:t[1],decoded:decode(t[1])}}var nip25_exports={};__export(nip25_exports,{finishReactionEvent:()=>finishReactionEvent,getReactedEventPointer:()=>getReactedEventPointer});function finishReactionEvent(e,t,n){const r=t.tags.filter(o=>o.length>=2&&(o[0]==="e"||o[0]==="p"));return finalizeEvent({...e,kind:Reaction,tags:[...e.tags??[],...r,["e",t.id],["p",t.pubkey]],content:e.content??"+"},n)}function getReactedEventPointer(e){if(e.kind!==Reaction)return;let t,n;for(let r=e.tags.length-1;r>=0&&(t===void 0||n===void 0);r--){const o=e.tags[r];o.length>=2&&(o[0]==="e"&&t===void 0?t=o:o[0]==="p"&&n===void 0&&(n=o))}if(!(t===void 0||n===void 0))return{id:t[1],relays:[t[2],n[2]].filter(r=>r!==void 0),author:n[1]}}var nip27_exports={};__export(nip27_exports,{parse:()=>parse3});var noCharacter=/\W/m,noURLCharacter=/\W |\W$|$|,| /m;function*parse3(e){const t=e.length;let n=0,r=0;for(;r<t;){let o=e.indexOf(":",r);if(o===-1)break;if(e.substring(o-5,o)==="nostr"){const s=e.substring(o+60).match(noCharacter),a=s?o+60+s.index:t;try{let l,{data:c,type:f}=decode(e.substring(o+1,a));switch(f){case"npub":l={pubkey:c};break;case"nsec":case"note":r=a+1;continue;default:l=c}n!==o-5&&(yield{type:"text",text:e.substring(n,o-5)}),yield{type:"reference",pointer:l},r=a,n=r;continue}catch{r=o+1;continue}}else if(e.substring(o-5,o)==="https"||e.substring(o-4,o)==="http"){const s=e.substring(o+4).match(noURLCharacter),a=s?o+4+s.index:t,l=e[o-1]==="s"?5:4;try{let c=new URL(e.substring(o-l,a));if(c.hostname.indexOf(".")===-1)throw new Error("invalid url");if(n!==o-l&&(yield{type:"text",text:e.substring(n,o-l)}),c.pathname.endsWith(".png")||c.pathname.endsWith(".jpg")||c.pathname.endsWith(".jpeg")||c.pathname.endsWith(".gif")||c.pathname.endsWith(".webp")){yield{type:"image",url:c.toString()},r=a,n=r;continue}if(c.pathname.endsWith(".mp4")||c.pathname.endsWith(".avi")||c.pathname.endsWith(".webm")||c.pathname.endsWith(".mkv")){yield{type:"video",url:c.toString()},r=a,n=r;continue}if(c.pathname.endsWith(".mp3")||c.pathname.endsWith(".aac")||c.pathname.endsWith(".ogg")||c.pathname.endsWith(".opus")){yield{type:"audio",url:c.toString()},r=a,n=r;continue}yield{type:"url",url:c.toString()},r=a,n=r;continue}catch{r=a+1;continue}}else if(e.substring(o-3,o)==="wss"||e.substring(o-2,o)==="ws"){const s=e.substring(o+4).match(noURLCharacter),a=s?o+4+s.index:t,l=e[o-1]==="s"?3:2;try{let c=new URL(e.substring(o-l,a));if(c.hostname.indexOf(".")===-1)throw new Error("invalid ws url");n!==o-l&&(yield{type:"text",text:e.substring(n,o-l)}),yield{type:"relay",url:c.toString()},r=a,n=r;continue}catch{r=a+1;continue}}else{r=o+1;continue}}n!==t&&(yield{type:"text",text:e.substring(n)})}var nip28_exports={};__export(nip28_exports,{channelCreateEvent:()=>channelCreateEvent,channelHideMessageEvent:()=>channelHideMessageEvent,channelMessageEvent:()=>channelMessageEvent,channelMetadataEvent:()=>channelMetadataEvent,channelMuteUserEvent:()=>channelMuteUserEvent});var channelCreateEvent=(e,t)=>{let n;if(typeof e.content=="object")n=JSON.stringify(e.content);else if(typeof e.content=="string")n=e.content;else return;return finalizeEvent({kind:ChannelCreation,tags:[...e.tags??[]],content:n,created_at:e.created_at},t)},channelMetadataEvent=(e,t)=>{let n;if(typeof e.content=="object")n=JSON.stringify(e.content);else if(typeof e.content=="string")n=e.content;else return;return finalizeEvent({kind:ChannelMetadata,tags:[["e",e.channel_create_event_id],...e.tags??[]],content:n,created_at:e.created_at},t)},channelMessageEvent=(e,t)=>{const n=[["e",e.channel_create_event_id,e.relay_url,"root"]];return e.reply_to_channel_message_event_id&&n.push(["e",e.reply_to_channel_message_event_id,e.relay_url,"reply"]),finalizeEvent({kind:ChannelMessage,tags:[...n,...e.tags??[]],content:e.content,created_at:e.created_at},t)},channelHideMessageEvent=(e,t)=>{let n;if(typeof e.content=="object")n=JSON.stringify(e.content);else if(typeof e.content=="string")n=e.content;else return;return finalizeEvent({kind:ChannelHideMessage,tags:[["e",e.channel_message_event_id],...e.tags??[]],content:n,created_at:e.created_at},t)},channelMuteUserEvent=(e,t)=>{let n;if(typeof e.content=="object")n=JSON.stringify(e.content);else if(typeof e.content=="string")n=e.content;else return;return finalizeEvent({kind:ChannelMuteUser,tags:[["p",e.pubkey_to_mute],...e.tags??[]],content:n,created_at:e.created_at},t)},nip30_exports={};__export(nip30_exports,{EMOJI_SHORTCODE_REGEX:()=>EMOJI_SHORTCODE_REGEX,matchAll:()=>matchAll,regex:()=>regex,replaceAll:()=>replaceAll});var EMOJI_SHORTCODE_REGEX=/:(\w+):/,regex=()=>new RegExp(`\\B${EMOJI_SHORTCODE_REGEX.source}\\B`,"g");function*matchAll(e){const t=e.matchAll(regex());for(const n of t)try{const[r,o]=n;yield{shortcode:r,name:o,start:n.index,end:n.index+r.length}}catch{}}function replaceAll(e,t){return e.replaceAll(regex(),(n,r)=>t({shortcode:n,name:r}))}var nip39_exports={};__export(nip39_exports,{useFetchImplementation:()=>useFetchImplementation3,validateGithub:()=>validateGithub});var _fetch3;try{_fetch3=fetch}catch{}function useFetchImplementation3(e){_fetch3=e}async function validateGithub(e,t,n){try{return await(await _fetch3(`https://gist.github.com/${t}/${n}/raw`)).text()===`Verifying that I control the following Nostr public key: ${e}`}catch{return!1}}var nip47_exports={};__export(nip47_exports,{makeNwcRequestEvent:()=>makeNwcRequestEvent,parseConnectionString:()=>parseConnectionString});function parseConnectionString(e){const{host:t,pathname:n,searchParams:r}=new URL(e),o=n||t,s=r.get("relay"),a=r.get("secret");if(!o||!s||!a)throw new Error("invalid connection string");return{pubkey:o,relay:s,secret:a}}async function makeNwcRequestEvent(e,t,n){const o=encrypt(t,e,JSON.stringify({method:"pay_invoice",params:{invoice:n}})),s={kind:NWCWalletRequest,created_at:Math.round(Date.now()/1e3),content:o,tags:[["p",e]]};return finalizeEvent(s,t)}var nip54_exports={};__export(nip54_exports,{normalizeIdentifier:()=>normalizeIdentifier});function normalizeIdentifier(e){return e=e.trim().toLowerCase(),e=e.normalize("NFKC"),Array.from(e).map(t=>new RegExp("\\p{Letter}","u").test(t)||new RegExp("\\p{Number}","u").test(t)?t:"-").join("")}var nip57_exports={};__export(nip57_exports,{getSatoshisAmountFromBolt11:()=>getSatoshisAmountFromBolt11,getZapEndpoint:()=>getZapEndpoint,makeZapReceipt:()=>makeZapReceipt,makeZapRequest:()=>makeZapRequest,useFetchImplementation:()=>useFetchImplementation4,validateZapRequest:()=>validateZapRequest});var _fetch4;try{_fetch4=fetch}catch{}function useFetchImplementation4(e){_fetch4=e}async function getZapEndpoint(e){try{let t="",{lud06:n,lud16:r}=JSON.parse(e.content);if(n){let{words:a}=bech32.decode(n,1e3),l=bech32.fromWords(a);t=utf8Decoder.decode(l)}else if(r){let[a,l]=r.split("@");t=new URL(`/.well-known/lnurlp/${a}`,`https://${l}`).toString()}else return null;let s=await(await _fetch4(t)).json();if(s.allowsNostr&&s.nostrPubkey)return s.callback}catch{}return null}function makeZapRequest(e){let t={kind:9734,created_at:Math.round(Date.now()/1e3),content:e.comment||"",tags:[["p","pubkey"in e?e.pubkey:e.event.pubkey],["amount",e.amount.toString()],["relays",...e.relays]]};if("event"in e){if(isReplaceableKind(e.event.kind)){const n=["a",`${e.event.kind}:${e.event.pubkey}:`];t.tags.push(n)}else if(isAddressableKind(e.event.kind)){let n=e.event.tags.find(([o,s])=>o==="d"&&s);if(!n)throw new Error("d tag not found or is empty");const r=["a",`${e.event.kind}:${e.event.pubkey}:${n[1]}`];t.tags.push(r)}t.tags.push(["k",e.event.kind.toString()])}return t}function validateZapRequest(e){let t;try{t=JSON.parse(e)}catch{return"Invalid zap request JSON."}if(!validateEvent(t))return"Zap request is not a valid Nostr event.";if(!verifyEvent(t))return"Invalid signature on zap request.";let n=t.tags.find(([s,a])=>s==="p"&&a);if(!n)return"Zap request doesn't have a 'p' tag.";if(!n[1].match(/^[a-f0-9]{64}$/))return"Zap request 'p' tag is not valid hex.";let r=t.tags.find(([s,a])=>s==="e"&&a);return r&&!r[1].match(/^[a-f0-9]{64}$/)?"Zap request 'e' tag is not valid hex.":t.tags.find(([s,a])=>s==="relays"&&a)?null:"Zap request doesn't have a 'relays' tag."}function makeZapReceipt({zapRequest:e,preimage:t,bolt11:n,paidAt:r}){let o=JSON.parse(e),s=o.tags.filter(([l])=>l==="e"||l==="p"||l==="a"),a={kind:9735,created_at:Math.round(r.getTime()/1e3),content:"",tags:[...s,["P",o.pubkey],["bolt11",n],["description",e]]};return t&&a.tags.push(["preimage",t]),a}function getSatoshisAmountFromBolt11(e){if(e.length<50)return 0;e=e.substring(0,50);const t=e.lastIndexOf("1");if(t===-1)return 0;const n=e.substring(0,t);if(!n.startsWith("lnbc"))return 0;const r=n.substring(4);if(r.length<1)return 0;const o=r[r.length-1],s=o.charCodeAt(0)-48,a=s>=0&&s<=9;let l=r.length-1;if(a&&l++,l<1)return 0;const c=parseInt(r.substring(0,l));switch(o){case"m":return c*1e5;case"u":return c*100;case"n":return c/10;case"p":return c/1e4;default:return c*1e8}}var nip98_exports={};__export(nip98_exports,{getToken:()=>getToken,hashPayload:()=>hashPayload,unpackEventFromToken:()=>unpackEventFromToken,validateEvent:()=>validateEvent2,validateEventKind:()=>validateEventKind,validateEventMethodTag:()=>validateEventMethodTag,validateEventPayloadTag:()=>validateEventPayloadTag,validateEventTimestamp:()=>validateEventTimestamp,validateEventUrlTag:()=>validateEventUrlTag,validateToken:()=>validateToken});var _authorizationScheme="Nostr ";async function getToken(e,t,n,r=!1,o){const s={kind:HTTPAuth,tags:[["u",e],["method",t]],created_at:Math.round(new Date().getTime()/1e3),content:""};o&&s.tags.push(["payload",hashPayload(o)]);const a=await n(s);return(r?_authorizationScheme:"")+base64.encode(utf8Encoder.encode(JSON.stringify(a)))}async function validateToken(e,t,n){const r=await unpackEventFromToken(e).catch(s=>{throw s});return await validateEvent2(r,t,n).catch(s=>{throw s})}async function unpackEventFromToken(e){if(!e)throw new Error("Missing token");e=e.replace(_authorizationScheme,"");const t=utf8Decoder.decode(base64.decode(e));if(!t||t.length===0||!t.startsWith("{"))throw new Error("Invalid token");return JSON.parse(t)}function validateEventTimestamp(e){return e.created_at?Math.round(new Date().getTime()/1e3)-e.created_at<60:!1}function validateEventKind(e){return e.kind===HTTPAuth}function validateEventUrlTag(e,t){const n=e.tags.find(r=>r[0]==="u");return n?n.length>0&&n[1]===t:!1}function validateEventMethodTag(e,t){const n=e.tags.find(r=>r[0]==="method");return n?n.length>0&&n[1].toLowerCase()===t.toLowerCase():!1}function hashPayload(e){const t=sha256(utf8Encoder.encode(JSON.stringify(e)));return bytesToHex(t)}function validateEventPayloadTag(e,t){const n=e.tags.find(o=>o[0]==="payload");if(!n)return!1;const r=hashPayload(t);return n.length>0&&n[1]===r}async function validateEvent2(e,t,n,r){if(!verifyEvent(e))throw new Error("Invalid nostr event, signature invalid");if(!validateEventKind(e))throw new Error("Invalid nostr event, kind invalid");if(!validateEventTimestamp(e))throw new Error("Invalid nostr event, created_at timestamp invalid");if(!validateEventUrlTag(e,t))throw new Error("Invalid nostr event, url tag invalid");if(!validateEventMethodTag(e,n))throw new Error("Invalid nostr event, method tag invalid");if(r&&typeof r=="object"&&Object.keys(r).length>0&&!validateEventPayloadTag(e,r))throw new Error("Invalid nostr event, payload tag does not match request body hash");return!0}function storedKey(e="token"){try{return auth.keyFromNsec(localStorage.getItem(e))}catch{const t=auth.randomKey();return localStorage.setItem(e,t.sec),t}}const auth={keyFromNsec:e=>({pub:getPub(e),sec:e,sign:t=>signEvent(t,e)}),randomKey:()=>{const e=nip19_exports.nsecEncode(generateSecretKey());return auth.keyFromNsec(e)},checkEvent:e=>verifyEvent(e)},bob=auth.keyFromNsec("nsec1qp3y43jmsdr665dc2gxmaxm6e5pqtyhqdr3zsfa902j2vr3tcpysrwnux0");function getPub(e){const t=nip19_exports.decode(e);if(t.type!=="nsec")throw new Error("Invalid secret key");const n=nip19_exports.npubEncode(getPublicKey(t.data));if(n.startsWith("npub1"))return n;throw new Error("Invalid public key")}const signEvent=(e,t)=>{let n={kind:1,tags:[],content:e,created_at:Math.floor(Date.now()/1e3)};return finalizeEvent(n,nip19_exports.decode(t).data)},htmlElement=(e,t,n="",r)=>{const o=document.createElement(e);return o.innerText=t,n&&o.classList.add(...n.split(".").filter(s=>s)),r&&Object.entries(r).forEach(([s,a])=>{s==="parent"&&a.appendChild(o),s==="children"?a.forEach(l=>o.appendChild(l)):s==="eventListeners"?Object.entries(a).forEach(([l,c])=>{o.addEventListener(l,c)}):s==="color"||s==="background"?o.style[s]=a:s==="style"?Object.entries(a).forEach(([l,c])=>{o.style.setProperty(l,c)}):o[s]=a}),o},popup=e=>{const t=htmlElement("div","","popup-background");return t.appendChild(e),document.body.appendChild(t),t.onclick=()=>{t.remove()},e.classList.add("popup-dialog"),t.appendChild(htmlElement("div","close","popup-close",{onclick:()=>{t.remove()}})),e.onclick=n=>{n.stopPropagation()},()=>t.remove()};class Writable{constructor(t){W(this,"value");W(this,"listeners",[]);this.value=t}get(){return this.value}set(t,n=!1){if(!(!n&&t===this.value)){for(const r of this.listeners)r(t);this.value=t}}update(t,n=!1){const r=t(this.value);this.set(r,n)}subscribe(t){this.listeners.push(t),t(this.value)}subscribeLater(t){this.listeners.push(t)}}class Stored extends Writable{constructor(n,r){localStorage.getItem(n)!==null&&(r=JSON.parse(localStorage.getItem(n)));super(r);W(this,"key");this.key=n}set(n){JSON.stringify(this.get())!==JSON.stringify(n)&&(super.set(n),localStorage.setItem(this.key,JSON.stringify(n)))}}const SHA256=async e=>{const t=await crypto.subtle.digest("SHA-256",new TextEncoder().encode(e));return Array.from(new Uint8Array(t)).map(r=>r.toString(16).padStart(2,"0")).join("")};async function ServerLogin(e,t,n){async function r(s){const a=signEvent(JSON.stringify(s),n.sec),l=await fetch(e,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(a)});if(l.ok)return JSON.parse(await l.json());throw new Error("Failed to send request:"+l.status)}const o=await Box2Serial(t);return await r({pubkey:n.pub,tag:"publish",app:o}),await r({pubkey:n.pub,tag:"host",appHash:o.hash,allowed:!0}),async(s,a,l=null)=>{const c=await lamHash(a,o),f={tag:"call",pubkey:n.pub,appHash:o.hash,lamHash:c,host:s,argument:l};return await r(f)}}const dummyContext={self:"npub1self",other:"npub1other",getTable:(e,t)=>({get:()=>Promise.resolve(t),set:()=>Promise.resolve(),update:()=>Promise.resolve(),delete:()=>Promise.resolve(),other:{get:()=>Promise.resolve(t),set:()=>Promise.resolve(),update:()=>Promise.resolve(),delete:()=>Promise.resolve()}})};function _lamHash(e,t){return SHA256(e+t)}async function lamHash(e,t){const n=await _lamHash(e.toString(),t.hash);if(!Object.values(t.apiHashes).includes(n))throw new Error("illegal lambda");return n}async function Box2Serial(e){const t=e.getCtx.toString(),n=Object.fromEntries(Object.entries(e.api).map(([s,a])=>[s,a.toString()])),r=await SHA256(JSON.stringify({getCtx:t,api:n})),o={};for(const[s,a]of Object.entries(n))o[s]=await _lamHash(a.toString(),r);return{getCtx:t,api:n,hash:r,apiHashes:o}}const msgBox={getCtx:e=>({msgs:e.getTable("msgs",[]),username:e.getTable("username","anonynmous"),followers:e.getTable("followers",[]),follows:e.getTable("follows",[]),add:(t,n)=>t.update(r=>r.includes(n)?r:[...r,n])}),api:{sendMsg:async(e,t)=>{const n={self:e.self,other:e.other,content:t};await e.msgs.update(r=>[...r,n]),await e.msgs.other.update(r=>[...r,n])},seeMsgs:(e,t)=>e.msgs.get(),setUsername:(e,t)=>e.username.set(t),getUsername:(e,t)=>e.username.other.get(),follow:async e=>{await e.add(e.followers.other,e.self),await e.add(e.follows,e.other)},unfollow:async e=>{await e.followers.other.update(t=>t.filter(n=>n!==e.self)),await e.follows.update(t=>t.filter(n=>n!==e.other))},getFollowers:e=>e.followers.other.get(),getFollows:e=>e.follows.other.get()}},key=storedKey();function chatView(e){const t=htmlElement("div","");return ServerLogin(e,msgBox,bob).then(async n=>{n(bob.pub,msgBox.api.setUsername,"bob")}).then(()=>{ServerLogin(e,msgBox,key).then(async n=>{const r=htmlElement("h1","Logged in as ");t.appendChild(r);const o=htmlElement("button","","");o.onclick=()=>{const d=htmlElement("div",""),y=popup(d);d.appendChild(htmlElement("h2","Change Username"));const w=htmlElement("input","");w.value=a.get(),w.addEventListener("keydown",async x=>{x.key==="Enter"&&(n(key.pub,msgBox.api.setUsername,w.value).then(()=>{a.set(w.value)}),y())}),w.focus(),d.appendChild(w)},r.appendChild(o);const s=new Writable(bob.pub),a=new Writable("anonynmous");n(key.pub,msgBox.api.getUsername).then(d=>{a.set(d)}),a.subscribe(d=>{o.innerHTML=d});const l=new Map,c=async d=>{if(l.has(d))return l.get(d);const y=await n(d,msgBox.api.getUsername);return l.set(d,y),y},f=htmlElement("button","chatting with","",{onclick:()=>{const d=htmlElement("div","");d.appendChild(htmlElement("h2","active users"));const y=popup(d);l.forEach((w,x)=>{const S=htmlElement("p",w,"",{onclick:async()=>{s.set(x),E(),y()}});d.appendChild(S)}),p&&d.appendChild(htmlElement("p","loading...","",{style:{color:"gray"}}))}});t.appendChild(f),s.subscribe(async d=>{c(d).then(y=>{f.innerHTML=`Chatting with ${y}`})});let p=!0;const u=htmlElement("div","");t.appendChild(u);const g=htmlElement("input","");g.setAttribute("type","text"),g.setAttribute("placeholder","Type a message"),t.appendChild(g),n(bob.pub,msgBox.api.follow).then(()=>{n(bob.pub,msgBox.api.getFollowers).then(d=>{Promise.all(d.map(c)).then(()=>{p=!1})})});const E=()=>n(key.pub,msgBox.api.seeMsgs).then(async d=>{u.innerText="";for(let y of d){if(y.self!==s.get()&&y.other!==s.get())continue;const w=await c(y.self);u.appendChild(htmlElement("p",`${w}: ${y.content}`))}});async function b(){const d=g.value;d&&(await n(s.get(),msgBox.api.sendMsg,d),E(),g.value="")}const h=htmlElement("button","send");h.onclick=()=>b(),g.addEventListener("keydown",async d=>{d.key==="Enter"&&!d.shiftKey&&(d.preventDefault(),await b())}),t.appendChild(h),E()})}),t}const chessCtx=e=>{const t=[[{type:"rook",color:"white"},{type:"knight",color:"white"},{type:"bishop",color:"white"},{type:"queen",color:"white"},{type:"king",color:"white"},{type:"bishop",color:"white"},{type:"knight",color:"white"},{type:"rook",color:"white"}],[{type:"pawn",color:"white"},{type:"pawn",color:"white"},{type:"pawn",color:"white"},{type:"pawn",color:"white"},{type:"pawn",color:"white"},{type:"pawn",color:"white"},{type:"pawn",color:"white"},{type:"pawn",color:"white"}],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[null,null,null,null,null,null,null,null],[{type:"pawn",color:"black"},{type:"pawn",color:"black"},{type:"pawn",color:"black"},{type:"pawn",color:"black"},{type:"pawn",color:"black"},{type:"pawn",color:"black"},{type:"pawn",color:"black"},{type:"pawn",color:"black"}],[{type:"rook",color:"black"},{type:"knight",color:"black"},{type:"bishop",color:"black"},{type:"queen",color:"black"},{type:"king",color:"black"},{type:"bishop",color:"black"},{type:"knight",color:"black"},{type:"rook",color:"black"}]];function n(h){return[h%10,Math.floor(h/10)]}function r(h){return h[0]+h[1]*10}if(r(n(21))!=21)throw new Error("posVec failed");function o(h){const[d,y]=n(h);return d>=0&&d<8&&y>=0&&y<8}function s(h,d){const[y,w]=n(d);return h[w][y]}function a(h,d,y){const[w,x]=n(d);h[x][w]=y}function l(h,d){for(let y=0;y<8;y++)for(let w=0;w<8;w++){const x=h[y][w];if(x&&x.color===d&&x.type==="king")return y*10+w}return null}const c=[10,-10,1,-1],f=[11,-11,9,-9];function p(h){switch(h.type){case"pawnmoved":case"pawnmoveddouble":return h.color==="white"?[10]:[-10];case"pawn":return h.color==="white"?[10,20]:[-10,-20];case"knight":return[12,8,21,19,-12,8,-21,-19];case"bishop":return f;case"rook":case"rookmoved":return c;case"queen":case"king":case"kingmoved":return f.concat(c)}}function u(h,d){const[y,w]=n(h),[x,S]=d;return r([y+x,w+S])}function g(h,d){var k,_;const y=s(h,d);if(!y)return[];let w=[],x=y.type;const S=p(y);if(x.startsWith("pawn")){w=S.map(B=>d+B).filter(o).filter(B=>s(h,B)==null);const $=y.color=="white"?1:-1;w=w.concat([1,-1].map(B=>u(d,[B,$])).filter(o).filter(B=>{let I=s(h,B);return I?I.color!=y.color:(I=s(h,B-$*10),I&&I.color!=y.color&&I.type=="pawnmoveddouble")}))}else{const $=x.startsWith("rook")||x.startsWith("bishop")||x.startsWith("queen");for(let B of S){let I=d;for(;I=I+B,!!o(I);){const L=s(h,I);if(L){y.color!==L.color&&w.push(I);break}if(w.push(I),!$)break}}x=="king"&&(s(h,d+1)==null&&s(h,d+2)==null&&((k=s(h,d+3))==null?void 0:k.type)=="rook"&&w.push(d+2),s(h,d-1)==null&&s(h,d-2)==null&&((_=s(h,d-4))==null?void 0:_.type)=="rook"&&w.push(d-2))}return w}function E(h,d){return g(h,d)}function b(h,d){if(h.winner!=null)return h;let y=s(h.board,d.start);if(!y||y.color!==h.turn||!E(h.board,d.start).includes(d.end))return h;if((y.type=="pawn"||y.type=="king"||y.type=="rook")&&(y.type+="moved"),y.type=="pawnmoved"&&Math.abs(d.end-d.start)==20&&(y.type="pawnmoveddouble"),y.type.startsWith("pawn")&&d.start%10!=d.end%10&&s(h.board,d.end)==null&&a(h.board,r([d.end%10,Math.floor(d.start/10)]),null),y.type.startsWith("king")){const x=d.start-d.end;x==2&&(a(h.board,d.end+1,{...y,type:"rookmoved"}),a(h.board,d.end-2,null)),x==-2&&(a(h.board,d.end-1,{...y,type:"rookmoved"}),a(h.board,d.end+1,null))}if(a(h.board,d.end,y),y.type.startsWith("pawn")){const x=Math.floor(d.end/10);(x==0||x==7)&&a(h.board,d.end,{...y,type:d.promo})}return a(h.board,d.start,null),h.turn=h.turn==="white"?"black":"white",l(h.board,h.turn)==null&&(h.winner=h.turn==="white"?"black":"white"),h}return{startBoard:t,hosting:e.getTable("hosting",null),playing:e.getTable("playing",null),invites:e.getTable("invites",[]),add:(h,d)=>h.update(y=>y.includes(d)?y:[...y,d]),makeMove:b}},pieceImages={pawn:"p",knight:"N",bishop:"B",rook:"R",queen:"Q",king:"K",kingmoved:"K",rookmoved:"R",pawnmoved:"p",pawnmoveddouble:"p"},chessView=e=>{const t=chessCtx(dummyContext);let n={white:dummyContext.self,black:dummyContext.other,board:t.startBoard,turn:"white",winner:null};const r=htmlElement("div","","chessboard");r.style.backgroundColor="#f0d9b5";const o=(window.innerWidth<window.innerHeight?window.innerWidth:window.innerHeight)*.6;r.style.width=o+"px",r.style.height=o+"px",r.style.margin="auto",r.style.position="relative",r.style.cursor="pointer";let s=null;const a=()=>{r.innerHTML="";for(let l=0;l<8;l++)for(let c=0;c<8;c++){const f=htmlElement("div","","square");f.style.width=o/8+"px",f.style.height=o/8+"px",r.appendChild(f),f.style.backgroundColor=(c+l)%2===0?"#b58863":"#f0d9b5",s&&s[0]===c&&s[1]===l&&(f.style.backgroundColor=(c+l)%2===0?"#c9b18f":"#ffd7be"),f.style.left=l*o/8+"px",f.style.bottom=c*o/8+"px",f.style.position="absolute",f.onclick=u=>{s&&s[0]===c&&s[1]===l?s=null:(s&&(n=t.makeMove(n,{start:s[0]*10+s[1],end:c*10+l,promo:"queen"})),s=[c,l]),a()};const p=n.board[c][l];if(p){const u=htmlElement("div",pieceImages[p.type],"piece");u.style.width=o/8+"px",u.style.height=o/8+"px",u.style.position="absolute",f.appendChild(u),u.style.color=p.color==="white"?"white":"black",u.style.fontWeight="bold",u.style.fontSize=o/8+"px"}}};return a(),htmlElement("div","","",{children:[htmlElement("h1","Chess"),htmlElement("p","Welcome to the chess page"),r]})},objectView=(e,t=0)=>{const n=" ".repeat(t);if(t>2)return htmlElement("p","...");if(e==null)return htmlElement("p",n+"null");if(e instanceof Array){const r=htmlElement("div","");for(const o of e)r.appendChild(objectView(o,t+1));return r}if(e instanceof Function)return htmlElement("p",n+e.toString());if(e==null)return htmlElement("p",n+"undefined");if(typeof e=="string")return htmlElement("p",n+e);if(typeof e=="number"||typeof e=="boolean")return htmlElement("p",n+e.toString());if(typeof e=="object"){const r=htmlElement("div","");for(const[o,s]of Object.entries(e).slice(0,10))r.appendChild(htmlElement("p",o)),r.appendChild(objectView(s,t+1));return r}return htmlElement("p","unknown")},fun=cmd=>eval(cmd);function Console(e,t=fun){const n=htmlElement("div","");n.style.textAlign="left",n.style.whiteSpace="pre",n.style.paddingLeft="2em";const r=htmlElement("input","");r.style.position="fixed",r.style.padding="1em",r.style.bottom="0",r.style.zIndex="1000",r.style.width="90%",r.style.left="1%",setTimeout(()=>{r.focus()},100),n.appendChild(r);const o=htmlElement("div","");n.appendChild(o),o.style.paddingBottom="5em";const s=new Stored("cmdhist",[]);let a=-1,l="";r.addEventListener("keydown",f=>{if(f.key==="Enter"){a=-1,s.update(p=>[...p,r.value]),c(">> "+r.value);try{c(t(r.value))}catch(p){console.log(r.value),console.error(p),c(p.message)}r.value=""}if(f.key==="Escape"&&(a=-1,r.value=""),f.key=="ArrowUp"){const p=s.get().filter(g=>g.startsWith(l)),u=p[p.length+a];u&&(r.value=u)}else if(f.key=="ArrowDown"){const p=s.get().filter(g=>g.startsWith(l)),u=p[p.length+a];u&&(r.value=u),a+=1}else l=r.value,a=-1});function c(f){o.appendChild(objectView(f)),setTimeout(()=>{n.scrollTop=n.scrollHeight},100)}return n}const appname="LamBox";document.title=appname;function getLocation(){const e=window.location.pathname.split("/").filter(Boolean),t=e.includes("local"),n=!e.includes(appname);return{serverLocal:t,frontendLocal:n,path:e.filter(r=>r!="local"&&r!=appname)}}let location=getLocation();const serverurl=location.serverLocal?"http://localhost:8080":"https://lambox.chickenkiller.com/",body=document.body,home=()=>htmlElement("div","","",{children:[htmlElement("h1","Home"),htmlElement("p","Welcome to the lambox"),...apps.filter(e=>e.path).map(e=>htmlElement("p","","",{children:[htmlElement("button",e.path,"",{onclick:()=>{route(e.path.split("/"))}})]}))]}),apps=[{init:home,path:"",cache:void 0},{init:chatView,path:"chat",cache:void 0},{init:chessView,path:"chess",cache:void 0},{init:url=>Console(url,cmd=>eval(cmd)),path:"console",cache:void 0}];route(location.path);window.addEventListener("popstate",e=>{location=getLocation(),route(location.path)});function route(e){let t=(location.serverLocal?"local":"")+"/"+(location.frontendLocal?"":appname)+"/"+e.join("/");t=window.location.origin+"/"+t.split("/").filter(Boolean).join("/"),window.history.pushState({},"",t),body.innerHTML="";for(const n of apps)n.path===e.join("/")&&(n.cache||(n.cache=n.init(serverurl)),body.appendChild(n.cache))}
